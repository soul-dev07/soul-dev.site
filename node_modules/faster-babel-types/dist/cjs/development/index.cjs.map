{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/comment.ts", "../../../src/is-node-type.ts", "../../../src/assert-node-type.ts", "../../../src/nodes/flow/expressions/typecast-expression.ts", "../../../src/nodes/flow/misc/any-type-annotation.ts", "../../../src/nodes/flow/misc/array-type-annotation.ts", "../../../src/nodes/flow/misc/boolean-literal-type-annotation.ts", "../../../src/nodes/flow/misc/boolean-type-annotation.ts", "../../../src/nodes/flow/misc/empty-type-annotation.ts", "../../../src/nodes/flow/misc/enum-boolean-body.ts", "../../../src/nodes/flow/misc/enum-boolean-member.ts", "../../../src/nodes/flow/misc/enum-defaulted-member.ts", "../../../src/nodes/flow/misc/enum-number-body.ts", "../../../src/nodes/flow/misc/enum-number-member.ts", "../../../src/nodes/flow/misc/enum-string-body.ts", "../../../src/nodes/flow/misc/enum-string-member.ts", "../../../src/nodes/flow/misc/enum-symbol-body.ts", "../../../src/nodes/flow/misc/exists-type-annotation.ts", "../../../src/nodes/flow/misc/function-type-annotation.ts", "../../../src/nodes/flow/misc/function-type-param.ts", "../../../src/nodes/flow/misc/generic-type-annotation.ts", "../../../src/nodes/flow/misc/indexed-access-type.ts", "../../../src/nodes/flow/misc/interface-extends.ts", "../../../src/nodes/flow/misc/interface-type-annotation.ts", "../../../src/nodes/flow/misc/intersection-type-annotation.ts", "../../../src/nodes/flow/misc/mixed-type-annotation.ts", "../../../src/nodes/flow/misc/null-literal-type-annotation.ts", "../../../src/nodes/flow/misc/nullable-type-annotation.ts", "../../../src/nodes/flow/misc/number-literal-type-annotation.ts", "../../../src/nodes/flow/misc/number-type-annotation.ts", "../../../src/nodes/flow/misc/object-type-annotation.ts", "../../../src/nodes/flow/misc/object-type-call-property.ts", "../../../src/nodes/flow/misc/object-type-indexer.ts", "../../../src/nodes/flow/misc/object-type-internal-slot.ts", "../../../src/nodes/flow/misc/object-type-property.ts", "../../../src/nodes/flow/misc/object-type-spread-property.ts", "../../../src/nodes/flow/misc/optional-indexed-access-type.ts", "../../../src/nodes/flow/misc/qualified-type-identifier.ts", "../../../src/nodes/flow/misc/string-literal-type-annotation.ts", "../../../src/nodes/flow/misc/string-type-annotation.ts", "../../../src/nodes/flow/misc/symbol-type-annotation.ts", "../../../src/nodes/flow/misc/this-type-annotation.ts", "../../../src/nodes/flow/misc/tuple-type-annotation.ts", "../../../src/nodes/flow/misc/type-annotation.ts", "../../../src/nodes/flow/misc/typeof-type-annotation.ts", "../../../src/nodes/flow/misc/union-type-annotation.ts", "../../../src/nodes/flow/misc/variance.ts", "../../../src/nodes/flow/misc/void-type-annotation.ts", "../../../src/nodes/flow/statements/declare-class.ts", "../../../src/nodes/flow/statements/declare-export-all-declaration.ts", "../../../src/nodes/flow/statements/declare-export-declaration.ts", "../../../src/nodes/flow/statements/declare-function.ts", "../../../src/nodes/flow/statements/declare-interface.ts", "../../../src/nodes/flow/statements/declare-module.ts", "../../../src/nodes/flow/statements/declare-module-exports.ts", "../../../src/nodes/flow/statements/declare-opaque-type.ts", "../../../src/nodes/flow/statements/declare-type-alias.ts", "../../../src/nodes/flow/statements/declare-variable.ts", "../../../src/nodes/flow/statements/enum-declaration.ts", "../../../src/nodes/flow/statements/interface-declaration.ts", "../../../src/nodes/flow/statements/opaque-type.ts", "../../../src/nodes/flow/statements/type-alias.ts", "../../../src/nodes/javascript/expressions/array-expression.ts", "../../../src/nodes/javascript/expressions/arrow-function-expression.ts", "../../../src/nodes/javascript/expressions/assignment-expression.ts", "../../../src/nodes/javascript/expressions/await-expression.ts", "../../../src/nodes/javascript/expressions/bigint-literal.ts", "../../../src/nodes/javascript/expressions/binary-expression.ts", "../../../src/nodes/javascript/expressions/bind-expression.ts", "../../../src/nodes/javascript/expressions/boolean-literal.ts", "../../../src/nodes/javascript/expressions/call-expression.ts", "../../../src/nodes/javascript/expressions/class-expression.ts", "../../../src/nodes/javascript/expressions/conditional-expression.ts", "../../../src/nodes/javascript/expressions/decimal-literal.ts", "../../../src/nodes/javascript/expressions/do-expression.ts", "../../../src/nodes/javascript/expressions/function-expression.ts", "../../../src/nodes/javascript/expressions/identifier.ts", "../../../src/nodes/javascript/expressions/import.ts", "../../../src/nodes/javascript/expressions/import-expression.ts", "../../../src/nodes/javascript/expressions/logical-expression.ts", "../../../src/nodes/javascript/expressions/member-expression.ts", "../../../src/nodes/javascript/expressions/meta-property.ts", "../../../src/nodes/javascript/expressions/module-expression.ts", "../../../src/nodes/javascript/expressions/new-expression.ts", "../../../src/nodes/javascript/expressions/null-literal.ts", "../../../src/nodes/javascript/expressions/numeric-literal.ts", "../../../src/nodes/javascript/expressions/object-expression.ts", "../../../src/nodes/javascript/expressions/optional-call-expression.ts", "../../../src/nodes/javascript/expressions/optional-member-expression.ts", "../../../src/nodes/javascript/expressions/parenthesized-expression.ts", "../../../src/nodes/javascript/expressions/pipeline-bare-function.ts", "../../../src/nodes/javascript/expressions/pipeline-primary-topic-reference.ts", "../../../src/nodes/javascript/expressions/pipeline-topic-expression.ts", "../../../src/nodes/javascript/expressions/record-expression.ts", "../../../src/nodes/javascript/expressions/regexp-literal.ts", "../../../src/nodes/javascript/expressions/sequence-expression.ts", "../../../src/nodes/javascript/expressions/string-literal.ts", "../../../src/nodes/javascript/expressions/super.ts", "../../../src/nodes/javascript/expressions/tagged-template-expression.ts", "../../../src/nodes/javascript/expressions/template-literal.ts", "../../../src/nodes/javascript/expressions/this-expression.ts", "../../../src/nodes/javascript/expressions/topic-reference.ts", "../../../src/nodes/javascript/expressions/tuple-expression.ts", "../../../src/nodes/javascript/expressions/unary-expression.ts", "../../../src/nodes/javascript/expressions/update-expression.ts", "../../../src/nodes/javascript/expressions/yield-expression.ts", "../../../src/nodes/javascript/misc/argument-placeholder.ts", "../../../src/nodes/javascript/misc/array-pattern.ts", "../../../src/nodes/javascript/misc/assignment-pattern.ts", "../../../src/nodes/javascript/misc/catch-clause.ts", "../../../src/nodes/javascript/misc/class-accessor-property.ts", "../../../src/nodes/javascript/misc/class-body.ts", "../../../src/nodes/javascript/misc/class-method.ts", "../../../src/nodes/javascript/misc/class-private-method.ts", "../../../src/nodes/javascript/misc/class-private-property.ts", "../../../src/nodes/javascript/misc/class-property.ts", "../../../src/nodes/javascript/misc/decorator.ts", "../../../src/nodes/javascript/misc/directive.ts", "../../../src/nodes/javascript/misc/directive-literal.ts", "../../../src/nodes/javascript/misc/export-default-specifier.ts", "../../../src/nodes/javascript/misc/export-namespace-specifier.ts", "../../../src/nodes/javascript/misc/export-specifier.ts", "../../../src/nodes/javascript/misc/import-default-specifier.ts", "../../../src/nodes/javascript/misc/import-namespace-specifier.ts", "../../../src/nodes/javascript/misc/import-specifier.ts", "../../../src/nodes/javascript/misc/object-method.ts", "../../../src/nodes/javascript/misc/object-pattern.ts", "../../../src/nodes/javascript/misc/object-property.ts", "../../../src/nodes/javascript/misc/private-name.ts", "../../../src/nodes/javascript/misc/rest-element.ts", "../../../src/nodes/javascript/misc/spread-element.ts", "../../../src/nodes/javascript/misc/static-block.ts", "../../../src/nodes/javascript/misc/switch-case.ts", "../../../src/nodes/javascript/misc/template-element.ts", "../../../src/nodes/javascript/misc/v8-intrinsic-identifier.ts", "../../../src/nodes/javascript/misc/variable-declarator.ts", "../../../src/nodes/javascript/statements/block-statement.ts", "../../../src/nodes/javascript/statements/break-statement.ts", "../../../src/nodes/javascript/statements/class-declaration.ts", "../../../src/nodes/javascript/statements/continue-statement.ts", "../../../src/nodes/javascript/statements/debugger-statement.ts", "../../../src/nodes/javascript/statements/do-while-statement.ts", "../../../src/nodes/javascript/statements/empty-statement.ts", "../../../src/nodes/javascript/statements/export-all-declaration.ts", "../../../src/nodes/javascript/statements/export-named-declaration.ts", "../../../src/nodes/javascript/statements/expression-statement.ts", "../../../src/nodes/javascript/statements/for-in-statement.ts", "../../../src/nodes/javascript/statements/for-of-statement.ts", "../../../src/nodes/javascript/statements/for-statement.ts", "../../../src/nodes/javascript/statements/function-declaration.ts", "../../../src/nodes/javascript/statements/if-statement.ts", "../../../src/nodes/javascript/statements/import-declaration.ts", "../../../src/nodes/javascript/statements/labeled-statement.ts", "../../../src/nodes/javascript/statements/return-statement.ts", "../../../src/nodes/javascript/statements/switch-statement.ts", "../../../src/nodes/javascript/statements/throw-statement.ts", "../../../src/nodes/javascript/statements/try-statement.ts", "../../../src/nodes/javascript/statements/variable-declaration.ts", "../../../src/nodes/javascript/statements/while-statement.ts", "../../../src/nodes/javascript/statements/with-statement.ts", "../../../src/nodes/jsx/jsx-attribute.ts", "../../../src/nodes/jsx/jsx-closing-element.ts", "../../../src/nodes/jsx/jsx-closing-fragment.ts", "../../../src/nodes/jsx/jsx-element.ts", "../../../src/nodes/jsx/jsx-empty-expression.ts", "../../../src/nodes/jsx/jsx-expression-container.ts", "../../../src/nodes/jsx/jsx-fragment.ts", "../../../src/nodes/jsx/jsx-identifier.ts", "../../../src/nodes/jsx/jsx-member-expression.ts", "../../../src/nodes/jsx/jsx-namespaced-name.ts", "../../../src/nodes/jsx/jsx-opening-element.ts", "../../../src/nodes/jsx/jsx-opening-fragment.ts", "../../../src/nodes/jsx/jsx-spread-attribute.ts", "../../../src/nodes/jsx/jsx-spread-child.ts", "../../../src/nodes/jsx/jsx-text.ts", "../../../src/nodes/typescript/expressions/ts-as-expression.ts", "../../../src/nodes/typescript/expressions/ts-instantiation-expression.ts", "../../../src/nodes/typescript/expressions/ts-non-null-expression.ts", "../../../src/nodes/typescript/expressions/ts-satisfies-expression.ts", "../../../src/nodes/typescript/expressions/ts-type-assertion.ts", "../../../src/nodes/typescript/misc/ts-any-keyword.ts", "../../../src/nodes/typescript/misc/ts-array-type.ts", "../../../src/nodes/typescript/misc/ts-bigint-keyword.ts", "../../../src/nodes/typescript/misc/ts-boolean-keyword.ts", "../../../src/nodes/typescript/misc/ts-call-signature-declaration.ts", "../../../src/nodes/typescript/misc/ts-conditional-type.ts", "../../../src/nodes/typescript/misc/ts-construct-signature-declaration.ts", "../../../src/nodes/typescript/misc/ts-constructor-type.ts", "../../../src/nodes/typescript/misc/ts-declare-method.ts", "../../../src/nodes/typescript/misc/ts-expression-with-type-arguments.ts", "../../../src/nodes/typescript/misc/ts-function-type.ts", "../../../src/nodes/typescript/misc/ts-import-type.ts", "../../../src/nodes/typescript/misc/ts-index-signature.ts", "../../../src/nodes/typescript/misc/ts-indexed-access-type.ts", "../../../src/nodes/typescript/misc/ts-infer-type.ts", "../../../src/nodes/typescript/misc/ts-intersection-type.ts", "../../../src/nodes/typescript/misc/ts-intrinsic-keyword.ts", "../../../src/nodes/typescript/misc/ts-literal-type.ts", "../../../src/nodes/typescript/misc/ts-mapped-type.ts", "../../../src/nodes/typescript/misc/ts-method-signature.ts", "../../../src/nodes/typescript/misc/ts-module-block.ts", "../../../src/nodes/typescript/misc/ts-named-tuple-member.ts", "../../../src/nodes/typescript/misc/ts-never-keyword.ts", "../../../src/nodes/typescript/misc/ts-null-keyword.ts", "../../../src/nodes/typescript/misc/ts-number-keyword.ts", "../../../src/nodes/typescript/misc/ts-object-keyword.ts", "../../../src/nodes/typescript/misc/ts-optional-type.ts", "../../../src/nodes/typescript/misc/ts-parameter-property.ts", "../../../src/nodes/typescript/misc/ts-parenthesized-type.ts", "../../../src/nodes/typescript/misc/ts-property-signature.ts", "../../../src/nodes/typescript/misc/ts-qualified-name.ts", "../../../src/nodes/typescript/misc/ts-rest-type.ts", "../../../src/nodes/typescript/misc/ts-string-keyword.ts", "../../../src/nodes/typescript/misc/ts-symbol-keyword.ts", "../../../src/nodes/typescript/misc/ts-this-type.ts", "../../../src/nodes/typescript/misc/ts-tuple-type.ts", "../../../src/nodes/typescript/misc/ts-type-annotation.ts", "../../../src/nodes/typescript/misc/ts-type-literal.ts", "../../../src/nodes/typescript/misc/ts-type-operator.ts", "../../../src/nodes/typescript/misc/ts-type-parameter.ts", "../../../src/nodes/typescript/misc/ts-type-parameter-declaration.ts", "../../../src/nodes/typescript/misc/ts-type-parameter-instantiation.ts", "../../../src/nodes/typescript/misc/ts-type-predicate.ts", "../../../src/nodes/typescript/misc/ts-type-query.ts", "../../../src/nodes/typescript/misc/ts-type-reference.ts", "../../../src/nodes/typescript/misc/ts-undefined-keyword.ts", "../../../src/nodes/typescript/misc/ts-union-type.ts", "../../../src/nodes/typescript/misc/ts-unknown-keyword.ts", "../../../src/nodes/typescript/misc/ts-void-keyword.ts", "../../../src/nodes/typescript/statements/ts-declare-function.ts", "../../../src/nodes/typescript/statements/ts-enum-declaration.ts", "../../../src/nodes/typescript/statements/ts-export-assignment.ts", "../../../src/nodes/typescript/statements/ts-import-equals-declaration.ts", "../../../src/nodes/typescript/statements/ts-interface-declaration.ts", "../../../src/nodes/typescript/statements/ts-module-declaration.ts", "../../../src/nodes/typescript/statements/ts-namespace-export-declaration.ts", "../../../src/nodes/typescript/statements/ts-type-alias-declaration.ts"],
  "sourcesContent": ["export * from './comment';\nexport * from './nodes';\n", "import type * as t from '@babel/types';\n\nexport function addComments<T extends t.Node>(\n  node: T,\n  type: t.CommentTypeShorthand,\n  comments: t.Comment[],\n): T {\n  const key = `${type}Comments` as const;\n\n  if (node[key]) {\n    if (type === 'leading') {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key].push.apply(node[key], comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n\n  return node;\n}\n\nexport function addComment<T extends t.Node>(\n  node: T,\n  type: t.CommentTypeShorthand,\n  comment: t.Comment,\n): T {\n  return addComments(node, type, [comment]);\n}\n", "import type * as t from '@babel/types';\n\nexport function is<\n  T extends t.Node['type'],\n  P extends Extract<\n    t.Node,\n    {\n      type: T;\n    }\n  >,\n>(type: T, node: t.Node | null | undefined): node is P {\n  return node != null && node.type === type;\n}\n\nexport function either<\n  T extends t.Node['type'],\n  P extends Extract<\n    t.Node,\n    {\n      type: T;\n    }\n  >,\n>(types: Set<T>, node: t.Node | null | undefined): node is P {\n  return node != null && types.has(node.type as T);\n}\n", "import type * as t from '@babel/types';\nimport { either, is } from './is-node-type';\n\n// https://github.com/babel/babel/blob/dba45d3ebc92a868c9b8952a6f407c6ab83c6b3f/packages/babel-types/src/asserts/generated/index.ts#L9\nexport function assert<\n  T extends t.Node['type'],\n  P extends Extract<\n    t.Node,\n    {\n      type: T;\n    }\n  >,\n>(type: T, node: t.Node | null | undefined): asserts node is P {\n  if (is(type, node)) {\n    throw new Error(\n      'Expected type \"' + type + '\" but instead got \"' + node.type + '\".',\n    );\n  }\n}\n\nexport function assertEither<\n  T extends t.Node['type'],\n  P extends Extract<\n    t.Node,\n    {\n      type: T;\n    }\n  >,\n>(\n  name: string,\n  types: Set<T>,\n  node: t.Node | null | undefined,\n): asserts node is P {\n  if (either(types, node)) {\n    throw new Error(\n      'Expected type \"' + name + '\" but instead got \"' + node.type + '\".',\n    );\n  }\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TypeCastExpression';\n\nexport function typeCastExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TypeAnnotation,\n): t.TypeCastExpression {\n  return {\n    type: TYPE,\n    expression,\n    typeAnnotation,\n  };\n}\n\nexport function isTypeCastExpression(\n  node: t.Node | null | undefined,\n): node is t.TypeCastExpression {\n  return is(TYPE, node);\n}\n\nexport function assertTypeCastExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.TypeCastExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'AnyTypeAnnotation';\n\nexport function anyTypeAnnotation(): t.AnyTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isAnyTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.AnyTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertAnyTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.AnyTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ArrayTypeAnnotation';\n\nexport function arrayTypeAnnotation(\n  elementType: t.FlowType,\n): t.ArrayTypeAnnotation {\n  return {\n    type: TYPE,\n    elementType,\n  };\n}\n\nexport function isArrayTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ArrayTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertArrayTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.ArrayTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'BooleanLiteralTypeAnnotation';\n\nexport function booleanLiteralTypeAnnotation(\n  value: boolean,\n): t.BooleanLiteralTypeAnnotation {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isBooleanLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.BooleanLiteralTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertBooleanLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.BooleanLiteralTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'BooleanTypeAnnotation';\n\nexport function booleanTypeAnnotation(): t.BooleanTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isBooleanTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.BooleanTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertBooleanTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.BooleanTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EmptyTypeAnnotation';\n\nexport function emptyTypeAnnotation(): t.EmptyTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isEmptyTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.EmptyTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertEmptyTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.EmptyTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumBooleanBody';\n\nexport function enumBooleanBody(\n  members: t.EnumBooleanMember[],\n): t.EnumBooleanBody {\n  return {\n    type: TYPE,\n    members,\n    explicitType: false,\n    hasUnknownMembers: false,\n  };\n}\n\nexport function isEnumBooleanBody(\n  node: t.Node | null | undefined,\n): node is t.EnumBooleanBody {\n  return is(TYPE, node);\n}\n\nexport function assertEnumBooleanBody(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumBooleanBody {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumBooleanMember';\n\nexport function enumBooleanMember(id: t.Identifier): t.EnumBooleanMember {\n  return {\n    type: TYPE,\n    id,\n    init: null as any,\n  };\n}\n\nexport function isEnumBooleanMember(\n  node: t.Node | null | undefined,\n): node is t.EnumBooleanMember {\n  return is(TYPE, node);\n}\n\nexport function assertEnumBooleanMember(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumBooleanMember {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumDefaultedMember';\n\nexport function enumDefaultedMember(id: t.Identifier): t.EnumDefaultedMember {\n  return {\n    type: TYPE,\n    id,\n  };\n}\n\nexport function isEnumDefaultedMember(\n  node: t.Node | null | undefined,\n): node is t.EnumDefaultedMember {\n  return is(TYPE, node);\n}\n\nexport function assertEnumDefaultedMember(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumDefaultedMember {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumNumberBody';\n\nexport function enumNumberBody(\n  members: t.EnumNumberMember[],\n): t.EnumNumberBody {\n  return {\n    type: TYPE,\n    members,\n    explicitType: false,\n    hasUnknownMembers: false,\n  };\n}\n\nexport function isEnumNumberBody(\n  node: t.Node | null | undefined,\n): node is t.EnumNumberBody {\n  return is(TYPE, node);\n}\n\nexport function assertEnumNumberBody(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumNumberBody {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumNumberMember';\n\nexport function enumNumberMember(\n  id: t.Identifier,\n  init: t.NumericLiteral,\n): t.EnumNumberMember {\n  return {\n    type: TYPE,\n    id,\n    init,\n  };\n}\n\nexport function isEnumNumberMember(\n  node: t.Node | null | undefined,\n): node is t.EnumNumberMember {\n  return is(TYPE, node);\n}\n\nexport function assertEnumNumberMember(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumNumberMember {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumStringBody';\n\nexport function enumStringBody(\n  members: Array<t.EnumStringMember | t.EnumDefaultedMember>,\n): t.EnumStringBody {\n  return {\n    type: TYPE,\n    members,\n    explicitType: false,\n    hasUnknownMembers: false,\n  };\n}\n\nexport function isEnumStringBody(\n  node: t.Node | null | undefined,\n): node is t.EnumStringBody {\n  return is(TYPE, node);\n}\n\nexport function assertEnumStringBody(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumStringBody {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumStringMember';\n\nexport function enumStringMember(\n  id: t.Identifier,\n  init: t.StringLiteral,\n): t.EnumStringMember {\n  return {\n    type: TYPE,\n    id,\n    init,\n  };\n}\n\nexport function isEnumStringMember(\n  node: t.Node | null | undefined,\n): node is t.EnumStringMember {\n  return is(TYPE, node);\n}\n\nexport function assertEnumStringMember(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumStringMember {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumSymbolBody';\n\nexport function enumSymbolBody(\n  members: t.EnumDefaultedMember[],\n): t.EnumSymbolBody {\n  return {\n    type: TYPE,\n    members,\n    hasUnknownMembers: false,\n  };\n}\n\nexport function isEnumSymbolBody(\n  node: t.Node | null | undefined,\n): node is t.EnumSymbolBody {\n  return is(TYPE, node);\n}\n\nexport function assertEnumSymbolBody(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumSymbolBody {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ExistsTypeAnnotation';\n\nexport function existsTypeAnnotation(): t.ExistsTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isExistsTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ExistsTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertExistsTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.ExistsTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'FunctionTypeAnnotation';\n\nexport function functionTypeAnnotation(\n  typeParameters: t.TypeParameterDeclaration | null | undefined,\n  params: t.FunctionTypeParam[],\n  rest: t.FunctionTypeParam | null | undefined,\n  returnType: t.FlowType,\n): t.FunctionTypeAnnotation {\n  return {\n    type: TYPE,\n    typeParameters,\n    params,\n    rest,\n    returnType,\n  };\n}\n\nexport function isFunctionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.FunctionTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertFunctionTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.FunctionTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'FunctionTypeParam';\n\nexport function functionTypeParam(\n  name: t.Identifier | null | undefined,\n  typeAnnotation: t.FlowType,\n): t.FunctionTypeParam {\n  return {\n    type: TYPE,\n    name,\n    typeAnnotation,\n  };\n}\n\nexport function isFunctionTypeParam(\n  node: t.Node | null | undefined,\n): node is t.FunctionTypeParam {\n  return is(TYPE, node);\n}\n\nexport function assertFunctionTypeParam(\n  node: t.Node | null | undefined,\n): asserts node is t.FunctionTypeParam {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'GenericTypeAnnotation';\n\nexport function genericTypeAnnotation(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null | undefined = null,\n): t.GenericTypeAnnotation {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n  };\n}\n\nexport function isGenericTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.GenericTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertGenericTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.GenericTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'IndexedAccessType';\n\nexport function indexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.IndexedAccessType {\n  return {\n    type: TYPE,\n    objectType,\n    indexType,\n  };\n}\n\nexport function isIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.IndexedAccessType {\n  return is(TYPE, node);\n}\n\nexport function assertIndexedAccessType(\n  node: t.Node | null | undefined,\n): asserts node is t.IndexedAccessType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'InterfaceExtends';\n\nexport function interfaceExtends(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null | undefined = null,\n): t.InterfaceExtends {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n  };\n}\n\nexport function isInterfaceExtends(\n  node: t.Node | null | undefined,\n): node is t.InterfaceExtends {\n  return is(TYPE, node);\n}\n\nexport function assertInterfaceExtends(\n  node: t.Node | null | undefined,\n): asserts node is t.InterfaceExtends {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'InterfaceTypeAnnotation';\n\nexport function interfaceTypeAnnotation(\n  interfaceExtends: t.InterfaceExtends[] | null | undefined,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceTypeAnnotation {\n  return {\n    type: TYPE,\n    extends: interfaceExtends,\n    body,\n  };\n}\n\nexport function isInterfaceTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.InterfaceTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertInterfaceTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.InterfaceTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'IntersectionTypeAnnotation';\n\nexport function intersectionTypeAnnotation(\n  types: t.FlowType[],\n): t.IntersectionTypeAnnotation {\n  return {\n    type: TYPE,\n    types,\n  };\n}\n\nexport function isIntersectionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.IntersectionTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertIntersectionTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.IntersectionTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'MixedTypeAnnotation';\n\nexport function mixedTypeAnnotation(): t.MixedTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isMixedTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.MixedTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertMixedTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.MixedTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'NullLiteralTypeAnnotation';\n\nexport function nullLiteralTypeAnnotation(): t.NullLiteralTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isNullLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NullLiteralTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertNullLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.NullLiteralTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'NullableTypeAnnotation';\n\nexport function nullableTypeAnnotation(\n  typeAnnotation: t.FlowType,\n): t.NullableTypeAnnotation {\n  return {\n    type: TYPE,\n    typeAnnotation,\n  };\n}\n\nexport function isNullableTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NullableTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertNullableTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.NullableTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'NumberLiteralTypeAnnotation';\n\nexport function numberLiteralTypeAnnotation(\n  value: number,\n): t.NumberLiteralTypeAnnotation {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isNumberLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NumberLiteralTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertNumberLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.NumberLiteralTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'NumberTypeAnnotation';\n\nexport function numberTypeAnnotation(): t.NumberTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isNumberTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NumberTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertNumberTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.NumberTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectTypeAnnotation';\n\nexport function objectTypeAnnotation(\n  properties: Array<t.ObjectTypeProperty | t.ObjectTypeSpreadProperty>,\n  indexers: t.ObjectTypeIndexer[] = [],\n  callProperties: t.ObjectTypeCallProperty[] = [],\n  internalSlots: t.ObjectTypeInternalSlot[] = [],\n  exact = false,\n): t.ObjectTypeAnnotation {\n  return {\n    type: TYPE,\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact,\n  };\n}\n\nexport function isObjectTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertObjectTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectTypeCallProperty';\n\nexport function objectTypeCallProperty(\n  value: t.FlowType,\n): t.ObjectTypeCallProperty {\n  return {\n    type: TYPE,\n    value,\n    static: false,\n  };\n}\n\nexport function isObjectTypeCallProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeCallProperty {\n  return is(TYPE, node);\n}\n\nexport function assertObjectTypeCallProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectTypeCallProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectTypeIndexer';\n\nexport function objectTypeIndexer(\n  id: t.Identifier | null | undefined,\n  key: t.FlowType,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeIndexer {\n  return {\n    type: TYPE,\n    id,\n    key,\n    value,\n    variance,\n    static: false,\n  };\n}\n\nexport function isObjectTypeIndexer(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeIndexer {\n  return is(TYPE, node);\n}\n\nexport function assertObjectTypeIndexer(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectTypeIndexer {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectTypeInternalSlot';\n\nexport function objectTypeInternalSlot(\n  id: t.Identifier,\n  value: t.FlowType,\n  optional: boolean,\n  isStatic: boolean,\n  method: boolean,\n): t.ObjectTypeInternalSlot {\n  return {\n    type: TYPE,\n    id,\n    value,\n    optional,\n    static: isStatic,\n    method,\n  };\n}\n\nexport function isObjectTypeInternalSlot(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeInternalSlot {\n  return is(TYPE, node);\n}\n\nexport function assertObjectTypeInternalSlot(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectTypeInternalSlot {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectTypeProperty';\n\nexport function objectTypeProperty(\n  key: t.Identifier | t.StringLiteral,\n  value: t.FlowType,\n  variance: t.Variance | null | undefined = null,\n): t.ObjectTypeProperty {\n  return {\n    type: TYPE,\n    key,\n    value,\n    variance,\n    kind: 'init',\n    method: false,\n    optional: false,\n    proto: false,\n    static: false,\n  };\n}\n\nexport function isObjectTypeProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeProperty {\n  return is(TYPE, node);\n}\n\nexport function assertObjectTypeProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectTypeProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectTypeSpreadProperty';\n\nexport function objectTypeSpreadProperty(\n  argument: t.FlowType,\n): t.ObjectTypeSpreadProperty {\n  return {\n    type: TYPE,\n    argument,\n  };\n}\n\nexport function isObjectTypeSpreadProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeSpreadProperty {\n  return is(TYPE, node);\n}\n\nexport function assertObjectTypeSpreadProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectTypeSpreadProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'OptionalIndexedAccessType';\n\nexport function optionalIndexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.OptionalIndexedAccessType {\n  return {\n    type: TYPE,\n    objectType,\n    indexType,\n    optional: false,\n  };\n}\n\nexport function isOptionalIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.OptionalIndexedAccessType {\n  return is(TYPE, node);\n}\n\nexport function assertOptionalIndexedAccessType(\n  node: t.Node | null | undefined,\n): asserts node is t.OptionalIndexedAccessType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'QualifiedTypeIdentifier';\n\nexport function qualifiedTypeIdentifier(\n  id: t.Identifier,\n  qualification: t.Identifier | t.QualifiedTypeIdentifier,\n): t.QualifiedTypeIdentifier {\n  return {\n    type: TYPE,\n    id,\n    qualification,\n  };\n}\n\nexport function isQualifiedTypeIdentifier(\n  node: t.Node | null | undefined,\n): node is t.QualifiedTypeIdentifier {\n  return is(TYPE, node);\n}\n\nexport function assertQualifiedTypeIdentifier(\n  node: t.Node | null | undefined,\n): asserts node is t.QualifiedTypeIdentifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'StringLiteralTypeAnnotation';\n\nexport function stringLiteralTypeAnnotation(\n  value: string,\n): t.StringLiteralTypeAnnotation {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isStringLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.StringLiteralTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertStringLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.StringLiteralTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'StringTypeAnnotation';\n\nexport function stringTypeAnnotation(): t.StringTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isStringTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.StringTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertStringTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.StringTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'SymbolTypeAnnotation';\n\nexport function symbolTypeAnnotation(): t.SymbolTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isSymbolTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.SymbolTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertSymbolTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.SymbolTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ThisTypeAnnotation';\n\nexport function thisTypeAnnotation(): t.ThisTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isThisTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ThisTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertThisTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.ThisTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TupleTypeAnnotation';\n\nexport function tupleTypeAnnotation(\n  types: t.FlowType[],\n): t.TupleTypeAnnotation {\n  return {\n    type: TYPE,\n    types,\n  };\n}\n\nexport function isTupleTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TupleTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertTupleTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.TupleTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TypeAnnotation';\n\nexport function typeAnnotation(typeAnnotation: t.FlowType): t.TypeAnnotation {\n  return {\n    type: TYPE,\n    typeAnnotation,\n  };\n}\n\nexport function isTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.TypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TypeofTypeAnnotation';\n\nexport function typeofTypeAnnotation(\n  argument: t.FlowType,\n): t.TypeofTypeAnnotation {\n  return {\n    type: TYPE,\n    argument,\n  };\n}\n\nexport function isTypeofTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TypeofTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertTypeofTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.TypeofTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'UnionTypeAnnotation';\n\nexport function unionTypeAnnotation(\n  types: t.FlowType[],\n): t.UnionTypeAnnotation {\n  return {\n    type: TYPE,\n    types,\n  };\n}\n\nexport function isUnionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.UnionTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertUnionTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.UnionTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'Variance';\n\nexport type VarianceKind = 'minus' | 'plus';\n\nexport function variance(kind: VarianceKind): t.Variance {\n  return {\n    type: TYPE,\n    kind,\n  };\n}\n\nexport function isVariance(\n  node: t.Node | null | undefined,\n): node is t.Variance {\n  return is(TYPE, node);\n}\n\nexport function assertVariance(\n  node: t.Node | null | undefined,\n): asserts node is t.Variance {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'VoidTypeAnnotation';\n\nexport function voidTypeAnnotation(): t.VoidTypeAnnotation {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isVoidTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.VoidTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertVoidTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.VoidTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareClass';\n\nexport function declareClass(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined,\n  interfaceExtends: t.InterfaceExtends[] | null | undefined,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareClass {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    extends: interfaceExtends,\n    body,\n  };\n}\n\nexport function isDeclareClass(\n  node: t.Node | null | undefined,\n): node is t.DeclareClass {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareClass(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareClass {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareExportAllDeclaration';\n\nexport function declareExportAllDeclaration(\n  source: t.StringLiteral,\n): t.DeclareExportAllDeclaration {\n  return {\n    type: TYPE,\n    source,\n  };\n}\n\nexport function isDeclareExportAllDeclaration(\n  node: t.Node | null | undefined,\n): node is t.DeclareExportAllDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareExportAllDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareExportAllDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareExportDeclaration';\n\nexport function declareExportDeclaration(\n  declaration?: t.Flow | null,\n  specifiers?: Array<t.ExportSpecifier | t.ExportNamespaceSpecifier> | null,\n  source?: t.StringLiteral | null,\n): t.DeclareExportDeclaration {\n  return {\n    type: TYPE,\n    declaration,\n    specifiers,\n    source,\n  };\n}\n\nexport function isDeclareExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.DeclareExportDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareExportDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareExportDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareFunction';\n\nexport function declareFunction(id: t.Identifier): t.DeclareFunction {\n  return {\n    type: TYPE,\n    id,\n  };\n}\n\nexport function isDeclareFunction(\n  node: t.Node | null | undefined,\n): node is t.DeclareFunction {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareFunction(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareFunction {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareInterface';\n\nexport function declareInterface(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined,\n  interfaceExtends: t.InterfaceExtends[] | null | undefined,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareInterface {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    extends: interfaceExtends,\n    body,\n  };\n}\n\nexport function isDeclareInterface(\n  node: t.Node | null | undefined,\n): node is t.DeclareInterface {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareInterface(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareInterface {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareModule';\n\nexport type DeclareModuleKind = 'CommonJS' | 'ES';\n\nexport function declareModule(\n  id: t.Identifier | t.StringLiteral,\n  body: t.BlockStatement,\n  kind?: DeclareModuleKind | null,\n): t.DeclareModule {\n  return {\n    type: TYPE,\n    id,\n    body,\n    kind,\n  };\n}\n\nexport function isDeclareModule(\n  node: t.Node | null | undefined,\n): node is t.DeclareModule {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareModule(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareModule {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareModuleExports';\n\nexport function declareModuleExports(\n  typeAnnotation: t.TypeAnnotation,\n): t.DeclareModuleExports {\n  return {\n    type: TYPE,\n    typeAnnotation,\n  };\n}\n\nexport function isDeclareModuleExports(\n  node: t.Node | null | undefined,\n): node is t.DeclareModuleExports {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareModuleExports(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareModuleExports {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareOpaqueType';\n\nexport function declareOpaqueType(\n  id: t.Identifier,\n  typeParameters?: t.TypeParameterDeclaration | null,\n  supertype?: t.FlowType | null,\n): t.DeclareOpaqueType {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    supertype,\n  };\n}\n\nexport function isDeclareOpaqueType(\n  node: t.Node | null | undefined,\n): node is t.DeclareOpaqueType {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareOpaqueType(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareOpaqueType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareTypeAlias';\n\nexport function declareTypeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null,\n  right: t.FlowType,\n): t.DeclareTypeAlias {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    right,\n  };\n}\n\nexport function isDeclareTypeAlias(\n  node: t.Node | null | undefined,\n): node is t.DeclareTypeAlias {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareTypeAlias(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareTypeAlias {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DeclareVariable';\n\nexport function declareVariable(id: t.Identifier): t.DeclareVariable {\n  return {\n    type: TYPE,\n    id,\n  };\n}\n\nexport function isDeclareVariable(\n  node: t.Node | null | undefined,\n): node is t.DeclareVariable {\n  return is(TYPE, node);\n}\n\nexport function assertDeclareVariable(\n  node: t.Node | null | undefined,\n): asserts node is t.DeclareVariable {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EnumDeclaration';\n\nexport function enumDeclaration(\n  id: t.Identifier,\n  body:\n    | t.EnumBooleanBody\n    | t.EnumNumberBody\n    | t.EnumStringBody\n    | t.EnumSymbolBody,\n): t.EnumDeclaration {\n  return {\n    type: TYPE,\n    id,\n    body,\n  };\n}\n\nexport function isEnumDeclaration(\n  node: t.Node | null | undefined,\n): node is t.EnumDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertEnumDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.EnumDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'InterfaceDeclaration';\n\nexport function interfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined,\n  interfaceExtends: t.InterfaceExtends[] | null | undefined,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceDeclaration {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    extends: interfaceExtends,\n    body,\n  };\n}\n\nexport function isInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): node is t.InterfaceDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.InterfaceDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'OpaqueType';\n\nexport function opaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined,\n  supertype: t.FlowType | null | undefined,\n  impltype: t.FlowType,\n): t.OpaqueType {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    supertype,\n    impltype,\n  };\n}\n\nexport function isOpaqueType(\n  node: t.Node | null | undefined,\n): node is t.OpaqueType {\n  return is(TYPE, node);\n}\n\nexport function assertOpaqueType(\n  node: t.Node | null | undefined,\n): asserts node is t.OpaqueType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TypeAlias';\n\nexport function typeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined,\n  right: t.FlowType,\n): t.TypeAlias {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    right,\n  };\n}\n\nexport function isTypeAlias(\n  node: t.Node | null | undefined,\n): node is t.TypeAlias {\n  return is(TYPE, node);\n}\n\nexport function assertTypeAlias(\n  node: t.Node | null | undefined,\n): asserts node is t.TypeAlias {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ArrayExpression';\n\nexport function arrayExpression(\n  elements: Array<null | t.Expression | t.SpreadElement> = [],\n): t.ArrayExpression {\n  return {\n    type: TYPE,\n    elements,\n  };\n}\n\nexport function isArrayExpression(\n  node: t.Node | null | undefined,\n): node is t.ArrayExpression {\n  return is(TYPE, node);\n}\n\nexport function assertArrayExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ArrayExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ArrowFunctionExpression';\n\nexport function arrowFunctionExpression(\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement | t.Expression,\n  async = false,\n): t.ArrowFunctionExpression {\n  return {\n    type: TYPE,\n    params,\n    body,\n    async,\n    expression: null as unknown as boolean, // ??? originally they use null\n  };\n}\n\nexport function isArrowFunctionExpression(\n  node: t.Node | null | undefined,\n): node is t.ArrowFunctionExpression {\n  return is(TYPE, node);\n}\n\nexport function assertArrowFunctionExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ArrowFunctionExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'AssignmentExpression';\n\nexport function assignmentExpression(\n  operator: string,\n  left: t.LVal | t.OptionalMemberExpression,\n  right: t.Expression,\n): t.AssignmentExpression {\n  return {\n    type: TYPE,\n    operator,\n    left,\n    right,\n  };\n}\n\nexport function isAssignmentExpression(\n  node: t.Node | null | undefined,\n): node is t.AssignmentExpression {\n  return is(TYPE, node);\n}\n\nexport function assertAssignmentExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.AssignmentExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'AwaitExpression';\n\nexport function awaitExpression(argument: t.Expression): t.AwaitExpression {\n  return {\n    type: TYPE,\n    argument,\n  };\n}\n\nexport function isAwaitExpression(\n  node: t.Node | null | undefined,\n): node is t.AwaitExpression {\n  return is(TYPE, node);\n}\n\nexport function assertAwaitExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.AwaitExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'BigIntLiteral';\n\nexport function bigIntLiteral(value: string): t.BigIntLiteral {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isBigIntLiteral(\n  node: t.Node | null | undefined,\n): node is t.BigIntLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertBigIntLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.BigIntLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'BinaryExpression';\n\nexport type BinaryExpressionOperator =\n  | '+'\n  | '-'\n  | '/'\n  | '%'\n  | '*'\n  | '**'\n  | '&'\n  | '|'\n  | '>>'\n  | '>>>'\n  | '<<'\n  | '^'\n  | '=='\n  | '==='\n  | '!='\n  | '!=='\n  | 'in'\n  | 'instanceof'\n  | '>'\n  | '<'\n  | '>='\n  | '<='\n  | '|>';\n\nexport function binaryExpression(\n  operator: BinaryExpressionOperator,\n  left: t.Expression | t.PrivateName,\n  right: t.Expression,\n): t.BinaryExpression {\n  return {\n    type: TYPE,\n    operator,\n    left,\n    right,\n  };\n}\n\nexport function isBinaryExpression(\n  node: t.Node | null | undefined,\n): node is t.BinaryExpression {\n  return is(TYPE, node);\n}\n\nexport function assertBinaryExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.BinaryExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'BindExpression';\n\nexport function bindExpression(\n  object: t.Expression,\n  callee: t.Expression,\n): t.BindExpression {\n  return {\n    type: TYPE,\n    object,\n    callee,\n  };\n}\n\nexport function isBindExpression(\n  node: t.Node | null | undefined,\n): node is t.BindExpression {\n  return is(TYPE, node);\n}\n\nexport function assertBindExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.BindExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'BooleanLiteral';\n\nexport function booleanLiteral(value: boolean): t.BooleanLiteral {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isBooleanLiteral(\n  node: t.Node | null | undefined,\n): node is t.BooleanLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertBooleanLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.BooleanLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'CallExpression';\n\nexport function callExpression(\n  callee: t.Expression | t.V8IntrinsicIdentifier,\n  args: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n): t.CallExpression {\n  return {\n    type: TYPE,\n    callee,\n    arguments: args,\n  };\n}\n\nexport function isCallExpression(\n  node: t.Node | null | undefined,\n): node is t.CallExpression {\n  return is(TYPE, node);\n}\n\nexport function assertCallExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.CallExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ClassExpression';\n\nexport function classExpression(\n  id: t.Identifier | null | undefined,\n  superClass: t.Expression | null | undefined,\n  body: t.ClassBody,\n  decorators: t.Decorator[] | null | undefined = null,\n): t.ClassExpression {\n  return {\n    type: TYPE,\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n}\n\nexport function isClassExpression(\n  node: t.Node | null | undefined,\n): node is t.ClassExpression {\n  return is(TYPE, node);\n}\n\nexport function assertClassExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ClassExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ConditionalExpression';\n\nexport function conditionalExpression(\n  test: t.Expression,\n  consequent: t.Expression,\n  alternate: t.Expression,\n): t.ConditionalExpression {\n  return {\n    type: TYPE,\n    test,\n    consequent,\n    alternate,\n  };\n}\n\nexport function isConditionalExpression(\n  node: t.Node | null | undefined,\n): node is t.ConditionalExpression {\n  return is(TYPE, node);\n}\n\nexport function assertConditionalExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ConditionalExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DecimalLiteral';\n\nexport function decimalLiteral(value: string): t.DecimalLiteral {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isDecimalLiteral(\n  node: t.Node | null | undefined,\n): node is t.DecimalLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertDecimalLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.DecimalLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DoExpression';\n\nexport function doExpression(\n  body: t.BlockStatement,\n  async = false,\n): t.DoExpression {\n  return {\n    type: TYPE,\n    body,\n    async,\n  };\n}\n\nexport function isDoExpression(\n  node: t.Node | null | undefined,\n): node is t.DoExpression {\n  return is(TYPE, node);\n}\n\nexport function assertDoExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.DoExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'FunctionExpression';\n\nexport function functionExpression(\n  id: t.Identifier | null | undefined,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  generator = false,\n  async = false,\n): t.FunctionExpression {\n  return {\n    type: TYPE,\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n}\n\nexport function isFunctionExpression(\n  node: t.Node | null | undefined,\n): node is t.FunctionExpression {\n  return is(TYPE, node);\n}\n\nexport function assertFunctionExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.FunctionExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'Identifier';\n\nexport function identifier(name: string): t.Identifier {\n  return {\n    type: TYPE,\n    name,\n  };\n}\n\nexport function isIdentifier(\n  node: t.Node | null | undefined,\n): node is t.Identifier {\n  return is(TYPE, node);\n}\n\nexport function assertIdentifier(\n  node: t.Node | null | undefined,\n): asserts node is t.Identifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'Import';\n\nexport function _import(): t.Import {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isImport(node: t.Node | null | undefined): node is t.Import {\n  return is(TYPE, node);\n}\n\nexport function assertImport(\n  node: t.Node | null | undefined,\n): asserts node is t.Import {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ImportExpression';\n\nexport function importExpression(\n  source: t.Expression,\n  options: t.Expression | null | undefined = null,\n): t.ImportExpression {\n  return {\n    type: TYPE,\n    source,\n    options,\n  };\n}\n\nexport function isImportExpression(\n  node: t.Node | null | undefined,\n): node is t.ImportExpression {\n  return is(TYPE, node);\n}\n\nexport function assertImportExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ImportExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'LogicalExpression';\n\nexport type LogicalExpressionOperator = '||' | '&&' | '??';\n\nexport function logicalExpression(\n  operator: LogicalExpressionOperator,\n  left: t.Expression,\n  right: t.Expression,\n): t.LogicalExpression {\n  return {\n    type: TYPE,\n    operator,\n    left,\n    right,\n  };\n}\n\nexport function isLogicalExpression(\n  node: t.Node | null | undefined,\n): node is t.LogicalExpression {\n  return is(TYPE, node);\n}\n\nexport function assertLogicalExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.LogicalExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'MemberExpression';\n\nexport function memberExpression(\n  object: t.Expression,\n  property: t.Expression | t.Identifier | t.PrivateName,\n  computed = false,\n  optional = false,\n): t.MemberExpression {\n  return {\n    type: TYPE,\n    object,\n    property,\n    computed,\n    optional,\n  };\n}\n\nexport function isMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.MemberExpression {\n  return is(TYPE, node);\n}\n\nexport function assertMemberExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.MemberExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'MetaProperty';\n\nexport function metaProperty(\n  meta: t.Identifier,\n  property: t.Identifier,\n): t.MetaProperty {\n  return {\n    type: TYPE,\n    meta,\n    property,\n  };\n}\n\nexport function isMetaProperty(\n  node: t.Node | null | undefined,\n): node is t.MetaProperty {\n  return is(TYPE, node);\n}\n\nexport function assertMetaProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.MetaProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ModuleExpression';\n\nexport function moduleExpression(body: t.Program): t.ModuleExpression {\n  return {\n    type: TYPE,\n    body,\n  };\n}\n\nexport function isModuleExpression(\n  node: t.Node | null | undefined,\n): node is t.ModuleExpression {\n  return is(TYPE, node);\n}\n\nexport function assertModuleExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ModuleExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'NewExpression';\n\nexport function newExpression(\n  callee: t.Expression | t.V8IntrinsicIdentifier,\n  args: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n): t.NewExpression {\n  return {\n    type: TYPE,\n    callee,\n    arguments: args,\n  };\n}\n\nexport function isNewExpression(\n  node: t.Node | null | undefined,\n): node is t.NewExpression {\n  return is(TYPE, node);\n}\n\nexport function assertNewExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.NewExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'NullLiteral';\n\nexport function nullLiteral(): t.NullLiteral {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isNullLiteral(\n  node: t.Node | null | undefined,\n): node is t.NullLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertNullLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.NullLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'NumericLiteral';\n\nexport function numericLiteral(value: number): t.NumericLiteral {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isNumericLiteral(\n  node: t.Node | null | undefined,\n): node is t.NumericLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertNumericLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.NumericLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectExpression';\n\nexport function objectExpression(\n  properties: Array<t.ObjectMethod | t.ObjectProperty | t.SpreadElement>,\n): t.ObjectExpression {\n  return {\n    type: TYPE,\n    properties,\n  };\n}\n\nexport function isObjectExpression(\n  node: t.Node | null | undefined,\n): node is t.ObjectExpression {\n  return is(TYPE, node);\n}\n\nexport function assertObjectExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'OptionalCallExpression';\n\nexport function optionalCallExpression(\n  callee: t.Expression,\n  args: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n  optional: boolean,\n): t.OptionalCallExpression {\n  return {\n    type: TYPE,\n    callee,\n    arguments: args,\n    optional,\n  };\n}\n\nexport function isOptionalCallExpression(\n  node: t.Node | null | undefined,\n): node is t.OptionalCallExpression {\n  return is(TYPE, node);\n}\n\nexport function assertOptionalCallExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.OptionalCallExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'OptionalMemberExpression';\n\nexport function optionalMemberExpression(\n  object: t.Expression,\n  property: t.Expression | t.Identifier,\n  computed = false,\n  optional = false,\n): t.OptionalMemberExpression {\n  return {\n    type: TYPE,\n    object,\n    property,\n    computed,\n    optional,\n  };\n}\n\nexport function isOptionalMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.OptionalMemberExpression {\n  return is(TYPE, node);\n}\n\nexport function assertOptionalMemberExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.OptionalMemberExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ParenthesizedExpression';\n\nexport function parenthesizedExpression(\n  expression: t.Expression,\n): t.ParenthesizedExpression {\n  return {\n    type: TYPE,\n    expression,\n  };\n}\n\nexport function isParenthesizedExpression(\n  node: t.Node | null | undefined,\n): node is t.ParenthesizedExpression {\n  return is(TYPE, node);\n}\n\nexport function assertParenthesizedExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ParenthesizedExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'PipelineBareFunction';\n\nexport function pipelineBareFunction(\n  callee: t.Expression,\n): t.PipelineBareFunction {\n  return {\n    type: TYPE,\n    callee,\n  };\n}\n\nexport function isPipelineBareFunction(\n  node: t.Node | null | undefined,\n): node is t.PipelineBareFunction {\n  return is(TYPE, node);\n}\n\nexport function assertPipelineBareFunction(\n  node: t.Node | null | undefined,\n): asserts node is t.PipelineBareFunction {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'PipelinePrimaryTopicReference';\n\nexport function pipelinePrimaryTopicReference(): t.PipelinePrimaryTopicReference {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isPipelinePrimaryTopicReference(\n  node: t.Node | null | undefined,\n): node is t.PipelinePrimaryTopicReference {\n  return is(TYPE, node);\n}\n\nexport function assertPipelinePrimaryTopicReference(\n  node: t.Node | null | undefined,\n): asserts node is t.PipelinePrimaryTopicReference {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'PipelineTopicExpression';\n\nexport function pipelineTopicExpression(\n  expression: t.Expression,\n): t.PipelineTopicExpression {\n  return {\n    type: TYPE,\n    expression,\n  };\n}\n\nexport function isPipelineTopicExpression(\n  node: t.Node | null | undefined,\n): node is t.PipelineTopicExpression {\n  return is(TYPE, node);\n}\n\nexport function assertPipelineTopicExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.PipelineTopicExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'RecordExpression';\n\nexport function recordExpression(\n  properties: Array<t.ObjectProperty | t.SpreadElement>,\n): t.RecordExpression {\n  return {\n    type: TYPE,\n    properties,\n  };\n}\n\nexport function isRecordExpression(\n  node: t.Node | null | undefined,\n): node is t.RecordExpression {\n  return is(TYPE, node);\n}\n\nexport function assertRecordExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.RecordExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'RegExpLiteral';\n\nexport function regExpLiteral(pattern: string, flags = ''): t.RegExpLiteral {\n  return {\n    type: TYPE,\n    pattern,\n    flags,\n  };\n}\n\nexport function isRegExpLiteral(\n  node: t.Node | null | undefined,\n): node is t.RegExpLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertRegExpLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.RegExpLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'SequenceExpression';\n\nexport function sequenceExpression(\n  expressions: t.Expression[],\n): t.SequenceExpression {\n  return {\n    type: TYPE,\n    expressions,\n  };\n}\n\nexport function isSequenceExpression(\n  node: t.Node | null | undefined,\n): node is t.SequenceExpression {\n  return is(TYPE, node);\n}\n\nexport function assertSequenceExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.SequenceExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'StringLiteral';\n\nexport function stringLiteral(value: string): t.StringLiteral {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isStringLiteral(\n  node: t.Node | null | undefined,\n): node is t.StringLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertStringLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.StringLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'Super';\n\nexport function _super(): t.Super {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isSuper(node: t.Node | null | undefined): node is t.Super {\n  return is(TYPE, node);\n}\n\nexport function assertSuper(\n  node: t.Node | null | undefined,\n): asserts node is t.Super {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TaggedTemplateExpression';\n\nexport function taggedTemplateExpression(\n  tag: t.Expression,\n  quasi: t.TemplateLiteral,\n): t.TaggedTemplateExpression {\n  return {\n    type: TYPE,\n    tag,\n    quasi,\n  };\n}\n\nexport function isTaggedTemplateExpression(\n  node: t.Node | null | undefined,\n): node is t.TaggedTemplateExpression {\n  return is(TYPE, node);\n}\n\nexport function assertTaggedTemplateExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.TaggedTemplateExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TemplateLiteral';\n\nexport function templateLiteral(\n  quasis: t.TemplateElement[],\n  expressions: Array<t.Expression | t.TSType>,\n): t.TemplateLiteral {\n  return {\n    type: TYPE,\n    quasis,\n    expressions,\n  };\n}\n\nexport function isTemplateLiteral(\n  node: t.Node | null | undefined,\n): node is t.TemplateLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertTemplateLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.TemplateLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ThisExpression';\n\nexport function thisExpression(): t.ThisExpression {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isThisExpression(\n  node: t.Node | null | undefined,\n): node is t.ThisExpression {\n  return is(TYPE, node);\n}\n\nexport function assertThisExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.ThisExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TopicReference';\n\nexport function topicReference(): t.TopicReference {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTopicReference(\n  node: t.Node | null | undefined,\n): node is t.TopicReference {\n  return is(TYPE, node);\n}\n\nexport function assertTopicReference(\n  node: t.Node | null | undefined,\n): asserts node is t.TopicReference {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TupleExpression';\n\nexport function tupleExpression(\n  elements: Array<t.Expression | t.SpreadElement> = [],\n): t.TupleExpression {\n  return {\n    type: TYPE,\n    elements,\n  };\n}\n\nexport function isTupleExpression(\n  node: t.Node | null | undefined,\n): node is t.TupleExpression {\n  return is(TYPE, node);\n}\n\nexport function assertTupleExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.TupleExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'UnaryExpression';\n\nexport type UnaryExpressionOperator =\n  | 'void'\n  | 'throw'\n  | 'delete'\n  | '!'\n  | '+'\n  | '-'\n  | '~'\n  | 'typeof';\n\nexport function unaryExpression(\n  operator: UnaryExpressionOperator,\n  argument: t.Expression,\n  prefix = true,\n): t.UnaryExpression {\n  return {\n    type: TYPE,\n    operator,\n    argument,\n    prefix,\n  };\n}\n\nexport function isUnaryExpression(\n  node: t.Node | null | undefined,\n): node is t.UnaryExpression {\n  return is(TYPE, node);\n}\n\nexport function assertUnaryExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.UnaryExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'UpdateExpression';\n\nexport type UpdateExpressionOperator = '++' | '--';\n\nexport function updateExpression(\n  operator: UpdateExpressionOperator,\n  argument: t.Expression,\n  prefix = false,\n): t.UpdateExpression {\n  return {\n    type: TYPE,\n    operator,\n    argument,\n    prefix,\n  };\n}\n\nexport function isUpdateExpression(\n  node: t.Node | null | undefined,\n): node is t.UpdateExpression {\n  return is(TYPE, node);\n}\n\nexport function assertUpdateExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.UpdateExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'YieldExpression';\n\nexport function yieldExpression(\n  argument: t.Expression | null | undefined = null,\n  delegate = false,\n): t.YieldExpression {\n  return {\n    type: TYPE,\n    argument,\n    delegate,\n  };\n}\n\nexport function isYieldExpression(\n  node: t.Node | null | undefined,\n): node is t.YieldExpression {\n  return is(TYPE, node);\n}\n\nexport function assertYieldExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.YieldExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ArgumentPlaceholder';\n\nexport function argumentPlaceholder(): t.ArgumentPlaceholder {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isArgumentPlaceholder(\n  node: t.Node | null | undefined,\n): node is t.ArgumentPlaceholder {\n  return is(TYPE, node);\n}\n\nexport function assertArgumentPlaceholder(\n  node: t.Node | null | undefined,\n): asserts node is t.ArgumentPlaceholder {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ArrayPattern';\n\nexport function arrayPattern(\n  elements: Array<null | t.PatternLike | t.LVal>,\n): t.ArrayPattern {\n  return {\n    type: TYPE,\n    elements,\n  };\n}\n\nexport function isArrayPattern(\n  node: t.Node | null | undefined,\n): node is t.ArrayPattern {\n  return is(TYPE, node);\n}\n\nexport function assertArrayPattern(\n  node: t.Node | null | undefined,\n): asserts node is t.ArrayPattern {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'AssignmentPattern';\n\nexport function assignmentPattern(\n  left:\n    | t.Identifier\n    | t.ObjectPattern\n    | t.ArrayPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n): t.AssignmentPattern {\n  return {\n    type: TYPE,\n    left,\n    right,\n  };\n}\n\nexport function isAssignmentPattern(\n  node: t.Node | null | undefined,\n): node is t.AssignmentPattern {\n  return is(TYPE, node);\n}\n\nexport function assertAssignmentPattern(\n  node: t.Node | null | undefined,\n): asserts node is t.AssignmentPattern {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'CatchClause';\n\nexport function catchClause(\n  param: t.Identifier | t.ArrayPattern | t.ObjectPattern | null | undefined,\n  body: t.BlockStatement,\n): t.CatchClause {\n  return {\n    type: TYPE,\n    param,\n    body,\n  };\n}\n\nexport function isCatchClause(\n  node: t.Node | null | undefined,\n): node is t.CatchClause {\n  return is(TYPE, node);\n}\n\nexport function assertCatchClause(\n  node: t.Node | null | undefined,\n): asserts node is t.CatchClause {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ClassAccessorProperty';\n\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression\n    | t.PrivateName,\n  value: t.Expression | null | undefined = null,\n  typeAnnotation:\n    | t.TypeAnnotation\n    | t.TSTypeAnnotation\n    | t.Noop\n    | null\n    | undefined = null,\n  decorators: t.Decorator[] | null | undefined = null,\n  computed = false,\n  isStatic = false,\n): t.ClassAccessorProperty {\n  return {\n    type: TYPE,\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: isStatic,\n  };\n}\n\nexport function isClassAccessorProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassAccessorProperty {\n  return is(TYPE, node);\n}\n\nexport function assertClassAccessorProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.ClassAccessorProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ClassBody';\n\nexport function classBody(\n  body: Array<\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty\n    | t.TSDeclareMethod\n    | t.TSIndexSignature\n    | t.StaticBlock\n  >,\n): t.ClassBody {\n  return {\n    type: TYPE,\n    body,\n  };\n}\n\nexport function isClassBody(\n  node: t.Node | null | undefined,\n): node is t.ClassBody {\n  return is(TYPE, node);\n}\n\nexport function assertClassBody(\n  node: t.Node | null | undefined,\n): asserts node is t.ClassBody {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ClassMethod';\n\nexport type ClassMethodKind = 'get' | 'set' | 'method' | 'constructor';\n\nexport function classMethod(\n  kind: ClassMethodKind,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  body: t.BlockStatement,\n  computed = false,\n  isStatic = false,\n  generator = false,\n  async = false,\n): t.ClassMethod {\n  return {\n    type: TYPE,\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: isStatic,\n    generator,\n    async,\n  };\n}\n\nexport function isClassMethod(\n  node: t.Node | null | undefined,\n): node is t.ClassMethod {\n  return is(TYPE, node);\n}\n\nexport function assertClassMethod(\n  node: t.Node | null | undefined,\n): asserts node is t.ClassMethod {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ClassPrivateMethod';\n\nexport type ClassPrivateMethodKind = 'get' | 'set' | 'method';\n\nexport function classPrivateMethod(\n  kind: ClassPrivateMethodKind,\n  key: t.PrivateName,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  body: t.BlockStatement,\n  computed = false,\n  isStatic = false,\n  generator = false,\n  async = false,\n): t.ClassPrivateMethod {\n  return {\n    type: TYPE,\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: isStatic,\n    generator,\n    async,\n  };\n}\n\nexport function isClassPrivateMethod(\n  node: t.Node | null | undefined,\n): node is t.ClassPrivateMethod {\n  return is(TYPE, node);\n}\n\nexport function assertClassPrivateMethod(\n  node: t.Node | null | undefined,\n): asserts node is t.ClassPrivateMethod {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ClassPrivateProperty';\n\nexport function classPrivateProperty(\n  key: t.PrivateName,\n  value?: t.Expression | null,\n  decorators?: t.Decorator[] | null,\n  isStatic = false,\n): t.ClassPrivateProperty {\n  return {\n    type: TYPE,\n    key,\n    value,\n    decorators,\n    static: isStatic,\n  };\n}\n\nexport function isClassPrivateProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassPrivateProperty {\n  return is(TYPE, node);\n}\n\nexport function assertClassPrivateProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.ClassPrivateProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ClassProperty';\n\nexport function classProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null,\n  decorators?: t.Decorator[] | null,\n  computed = false,\n  isStatic = false,\n): t.ClassProperty {\n  return {\n    type: TYPE,\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: isStatic,\n  };\n}\n\nexport function isClassProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassProperty {\n  return is(TYPE, node);\n}\n\nexport function assertClassProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.ClassProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'Decorator';\n\nexport function decorator(expression: t.Expression): t.Decorator {\n  return {\n    type: TYPE,\n    expression,\n  };\n}\n\nexport function isDecorator(\n  node: t.Node | null | undefined,\n): node is t.Decorator {\n  return is(TYPE, node);\n}\n\nexport function assertDecorator(\n  node: t.Node | null | undefined,\n): asserts node is t.Decorator {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'Directive';\n\nexport function directive(value: t.DirectiveLiteral): t.Directive {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isDirective(\n  node: t.Node | null | undefined,\n): node is t.Directive {\n  return is(TYPE, node);\n}\n\nexport function assertDirective(\n  node: t.Node | null | undefined,\n): asserts node is t.Directive {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DirectiveLiteral';\n\nexport function directiveLiteral(value: string): t.DirectiveLiteral {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isDirectiveLiteral(\n  node: t.Node | null | undefined,\n): node is t.DirectiveLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertDirectiveLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.DirectiveLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ExportDefaultSpecifier';\n\nexport function exportDefaultSpecifier(\n  exported: t.Identifier,\n): t.ExportDefaultSpecifier {\n  return {\n    type: TYPE,\n    exported,\n  };\n}\n\nexport function isExportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportDefaultSpecifier {\n  return is(TYPE, node);\n}\n\nexport function assertExportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): asserts node is t.ExportDefaultSpecifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ExportNamespaceSpecifier';\n\nexport function exportNamespaceSpecifier(\n  exported: t.Identifier,\n): t.ExportNamespaceSpecifier {\n  return {\n    type: TYPE,\n    exported,\n  };\n}\n\nexport function isExportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportNamespaceSpecifier {\n  return is(TYPE, node);\n}\n\nexport function assertExportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): asserts node is t.ExportNamespaceSpecifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ExportSpecifier';\n\nexport function exportSpecifier(\n  local: t.Identifier,\n  exported: t.Identifier | t.StringLiteral,\n): t.ExportSpecifier {\n  return {\n    type: TYPE,\n    local,\n    exported,\n  };\n}\n\nexport function isExportSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportSpecifier {\n  return is(TYPE, node);\n}\n\nexport function assertExportSpecifier(\n  node: t.Node | null | undefined,\n): asserts node is t.ExportSpecifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ImportDefaultSpecifier';\n\nexport function importDefaultSpecifier(\n  local: t.Identifier,\n): t.ImportDefaultSpecifier {\n  return {\n    type: TYPE,\n    local,\n  };\n}\n\nexport function isImportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportDefaultSpecifier {\n  return is(TYPE, node);\n}\n\nexport function assertImportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): asserts node is t.ImportDefaultSpecifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ImportNamespaceSpecifier';\n\nexport function importNamespaceSpecifier(\n  local: t.Identifier,\n): t.ImportNamespaceSpecifier {\n  return {\n    type: TYPE,\n    local,\n  };\n}\n\nexport function isImportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportNamespaceSpecifier {\n  return is(TYPE, node);\n}\n\nexport function assertImportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): asserts node is t.ImportNamespaceSpecifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ImportSpecifier';\n\nexport function importSpecifier(\n  local: t.Identifier,\n  imported: t.Identifier | t.StringLiteral,\n): t.ImportSpecifier {\n  return {\n    type: TYPE,\n    local,\n    imported,\n  };\n}\n\nexport function isImportSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportSpecifier {\n  return is(TYPE, node);\n}\n\nexport function assertImportSpecifier(\n  node: t.Node | null | undefined,\n): asserts node is t.ImportSpecifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectMethod';\n\nexport function objectMethod(\n  kind: 'method' | 'get' | 'set',\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  computed = false,\n  generator = false,\n  async = false,\n): t.ObjectMethod {\n  return {\n    type: TYPE,\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async,\n  };\n}\n\nexport function isObjectMethod(\n  node: t.Node | null | undefined,\n): node is t.ObjectMethod {\n  return is(TYPE, node);\n}\n\nexport function assertObjectMethod(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectMethod {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectPattern';\n\nexport function objectPattern(\n  properties: Array<t.RestElement | t.ObjectProperty>,\n): t.ObjectPattern {\n  return {\n    type: TYPE,\n    properties,\n  };\n}\n\nexport function isObjectPattern(\n  node: t.Node | null | undefined,\n): node is t.ObjectPattern {\n  return is(TYPE, node);\n}\n\nexport function assertObjectPattern(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectPattern {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ObjectProperty';\n\nexport function objectProperty(\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.DecimalLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed = false,\n  shorthand = false,\n  decorators: t.Decorator[] | null | undefined = null,\n): t.ObjectProperty {\n  return {\n    type: TYPE,\n    key,\n    value,\n    computed,\n    shorthand,\n    decorators,\n  };\n}\n\nexport function isObjectProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectProperty {\n  return is(TYPE, node);\n}\n\nexport function assertObjectProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.ObjectProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'PrivateName';\n\nexport function privateName(id: t.Identifier): t.PrivateName {\n  return {\n    type: TYPE,\n    id,\n  };\n}\n\nexport function isPrivateName(\n  node: t.Node | null | undefined,\n): node is t.PrivateName {\n  return is(TYPE, node);\n}\n\nexport function assertPrivateName(\n  node: t.Node | null | undefined,\n): asserts node is t.PrivateName {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'RestElement';\n\nexport function restElement(argument: t.LVal): t.RestElement {\n  return {\n    type: TYPE,\n    argument,\n  };\n}\n\nexport function isRestElement(\n  node: t.Node | null | undefined,\n): node is t.RestElement {\n  return is(TYPE, node);\n}\n\nexport function assertRestElement(\n  node: t.Node | null | undefined,\n): asserts node is t.RestElement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'SpreadElement';\n\nexport function spreadElement(argument: t.Expression): t.SpreadElement {\n  return {\n    type: TYPE,\n    argument,\n  };\n}\n\nexport function isSpreadElement(\n  node: t.Node | null | undefined,\n): node is t.SpreadElement {\n  return is(TYPE, node);\n}\n\nexport function assertSpreadElement(\n  node: t.Node | null | undefined,\n): asserts node is t.SpreadElement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'StaticBlock';\n\nexport function staticBlock(body: t.Statement[]): t.StaticBlock {\n  return {\n    type: TYPE,\n    body,\n  };\n}\n\nexport function isStaticBlock(\n  node: t.Node | null | undefined,\n): node is t.StaticBlock {\n  return is(TYPE, node);\n}\n\nexport function assertStaticBlock(\n  node: t.Node | null | undefined,\n): asserts node is t.StaticBlock {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'SwitchCase';\n\nexport function switchCase(\n  test: t.Expression | null | undefined,\n  consequent: t.Statement[],\n): t.SwitchCase {\n  return {\n    type: TYPE,\n    test,\n    consequent,\n  };\n}\n\nexport function isSwitchCase(\n  node: t.Node | null | undefined,\n): node is t.SwitchCase {\n  return is(TYPE, node);\n}\n\nexport function assertSwitchCase(\n  node: t.Node | null | undefined,\n): asserts node is t.SwitchCase {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TemplateElement';\n\nexport function templateElement(\n  value: { raw: string; cooked?: string },\n  tail = false,\n): t.TemplateElement {\n  return {\n    type: TYPE,\n    value,\n    tail,\n  };\n}\n\nexport function isTemplateElement(\n  node: t.Node | null | undefined,\n): node is t.TemplateElement {\n  return is(TYPE, node);\n}\n\nexport function assertTemplateElement(\n  node: t.Node | null | undefined,\n): asserts node is t.TemplateElement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'V8IntrinsicIdentifier';\n\nexport function v8IntrinsicIdentifier(name: string): t.V8IntrinsicIdentifier {\n  return {\n    type: TYPE,\n    name,\n  };\n}\n\nexport function isV8IntrinsicIdentifier(\n  node: t.Node | null | undefined,\n): node is t.V8IntrinsicIdentifier {\n  return is(TYPE, node);\n}\n\nexport function assertV8IntrinsicIdentifier(\n  node: t.Node | null | undefined,\n): asserts node is t.V8IntrinsicIdentifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'VariableDeclarator';\n\nexport function variableDeclarator(\n  id: t.LVal,\n  init: t.Expression | null | undefined = null,\n): t.VariableDeclarator {\n  return {\n    type: TYPE,\n    id,\n    init,\n  };\n}\n\nexport function isVariableDeclarator(\n  node: t.Node | null | undefined,\n): node is t.VariableDeclarator {\n  return is(TYPE, node);\n}\n\nexport function assertVariableDeclarator(\n  node: t.Node | null | undefined,\n): asserts node is t.VariableDeclarator {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'BlockStatement';\n\nexport function blockStatement(\n  body: t.Statement[],\n  directives: t.Directive[] = [],\n): t.BlockStatement {\n  return {\n    type: TYPE,\n    body,\n    directives,\n  };\n}\n\nexport function isBlockStatement(\n  node: t.Node | null | undefined,\n): node is t.BlockStatement {\n  return is(TYPE, node);\n}\n\nexport function assertBlockStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.BlockStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'BreakStatement';\n\nexport function breakStatement(\n  label: t.Identifier | null | undefined = null,\n): t.BreakStatement {\n  return {\n    type: TYPE,\n    label,\n  };\n}\n\nexport function isBreakStatement(\n  node: t.Node | null | undefined,\n): node is t.BreakStatement {\n  return is(TYPE, node);\n}\n\nexport function assertBreakStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.BreakStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ClassDeclaration';\n\nexport function classDeclaration(\n  id: t.Identifier | null | undefined,\n  superClass: t.Expression | null | undefined,\n  body: t.ClassBody,\n  decorators: t.Decorator[] | null | undefined = null,\n): t.ClassDeclaration {\n  return {\n    type: TYPE,\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n}\n\nexport function isClassDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ClassDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertClassDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.ClassDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ContinueStatement';\n\nexport function continueStatement(\n  label: t.Identifier | null | undefined = null,\n): t.ContinueStatement {\n  return {\n    type: TYPE,\n    label,\n  };\n}\n\nexport function isContinueStatement(\n  node: t.Node | null | undefined,\n): node is t.ContinueStatement {\n  return is(TYPE, node);\n}\n\nexport function assertContinueStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.ContinueStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DebuggerStatement';\n\nexport function debuggerStatement(): t.DebuggerStatement {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isDebuggerStatement(\n  node: t.Node | null | undefined,\n): node is t.DebuggerStatement {\n  return is(TYPE, node);\n}\n\nexport function assertDebuggerStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.DebuggerStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'DoWhileStatement';\n\nexport function doWhileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.DoWhileStatement {\n  return {\n    type: TYPE,\n    test,\n    body,\n  };\n}\n\nexport function isDoWhileStatement(\n  node: t.Node | null | undefined,\n): node is t.DoWhileStatement {\n  return is(TYPE, node);\n}\n\nexport function assertDoWhileStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.DoWhileStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'EmptyStatement';\n\nexport function emptyStatement(): t.EmptyStatement {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isEmptyStatement(\n  node: t.Node | null | undefined,\n): node is t.EmptyStatement {\n  return is(TYPE, node);\n}\n\nexport function assertEmptyStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.EmptyStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ExportAllDeclaration';\n\nexport function exportAllDeclaration(\n  source: t.StringLiteral,\n): t.ExportAllDeclaration {\n  return {\n    type: TYPE,\n    source,\n  };\n}\n\nexport function isExportAllDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportAllDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertExportAllDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.ExportAllDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ExportNamedDeclaration';\n\nexport function exportNamedDeclaration(\n  declaration: t.Declaration | null | undefined = null,\n  specifiers: Array<\n    t.ExportSpecifier | t.ExportDefaultSpecifier | t.ExportNamespaceSpecifier\n  > = [],\n  source: t.StringLiteral | null | undefined = null,\n): t.ExportNamedDeclaration {\n  return {\n    type: TYPE,\n    declaration,\n    specifiers,\n    source,\n  };\n}\n\nexport function isExportNamedDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportNamedDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertExportNamedDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.ExportNamedDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ExpressionStatement';\n\nexport function expressionStatement(\n  expression: t.Expression,\n): t.ExpressionStatement {\n  return {\n    type: TYPE,\n    expression,\n  };\n}\n\nexport function isExpressionStatement(\n  node: t.Node | null | undefined,\n): node is t.ExpressionStatement {\n  return is(TYPE, node);\n}\n\nexport function assertExpressionStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.ExpressionStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ForInStatement';\n\nexport function forInStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n): t.ForInStatement {\n  return {\n    type: TYPE,\n    left,\n    right,\n    body,\n  };\n}\n\nexport function isForInStatement(\n  node: t.Node | null | undefined,\n): node is t.ForInStatement {\n  return is(TYPE, node);\n}\n\nexport function assertForInStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.ForInStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ForOfStatement';\n\nexport function forOfStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n  isAwait: boolean,\n): t.ForOfStatement {\n  return {\n    type: TYPE,\n    left,\n    right,\n    body,\n    await: isAwait,\n  };\n}\n\nexport function isForOfStatement(\n  node: t.Node | null | undefined,\n): node is t.ForOfStatement {\n  return is(TYPE, node);\n}\n\nexport function assertForOfStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.ForOfStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ForStatement';\n\nexport function forStatement(\n  init: t.VariableDeclaration | t.Expression | null | undefined,\n  test: t.Expression | null | undefined,\n  update: t.Expression | null | undefined,\n  body: t.Statement,\n): t.ForStatement {\n  return {\n    type: TYPE,\n    init,\n    test,\n    update,\n    body,\n  };\n}\n\nexport function isForStatement(\n  node: t.Node | null | undefined,\n): node is t.ForStatement {\n  return is(TYPE, node);\n}\n\nexport function assertForStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.ForStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'FunctionDeclaration';\n\nexport function functionDeclaration(\n  id: t.Identifier | null | undefined,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  generator = false,\n  async = false,\n): t.FunctionDeclaration {\n  return {\n    type: TYPE,\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n}\n\nexport function isFunctionDeclaration(\n  node: t.Node | null | undefined,\n): node is t.FunctionDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertFunctionDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.FunctionDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'IfStatement';\n\nexport function ifStatement(\n  test: t.Expression,\n  consequent: t.Statement,\n  alternate: t.Statement | null | undefined = null,\n): t.IfStatement {\n  return {\n    type: TYPE,\n    test,\n    consequent,\n    alternate,\n  };\n}\n\nexport function isIfStatement(\n  node: t.Node | null | undefined,\n): node is t.IfStatement {\n  return is(TYPE, node);\n}\n\nexport function assertIfStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.IfStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ImportDeclaration';\n\nexport function importDeclaration(\n  specifiers: Array<\n    t.ImportSpecifier | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier\n  >,\n  source: t.StringLiteral,\n): t.ImportDeclaration {\n  return {\n    type: TYPE,\n    specifiers,\n    source,\n  };\n}\n\nexport function isImportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ImportDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertImportDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.ImportDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'LabeledStatement';\n\nexport function labeledStatement(\n  label: t.Identifier,\n  body: t.Statement,\n): t.LabeledStatement {\n  return {\n    type: TYPE,\n    label,\n    body,\n  };\n}\n\nexport function isLabeledStatement(\n  node: t.Node | null | undefined,\n): node is t.LabeledStatement {\n  return is(TYPE, node);\n}\n\nexport function assertLabeledStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.LabeledStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ReturnStatement';\n\nexport function returnStatement(\n  argument: t.Expression | null | undefined = null,\n): t.ReturnStatement {\n  return {\n    type: TYPE,\n    argument,\n  };\n}\n\nexport function isReturnStatement(\n  node: t.Node | null | undefined,\n): node is t.ReturnStatement {\n  return is(TYPE, node);\n}\n\nexport function assertReturnStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.ReturnStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'SwitchStatement';\n\nexport function switchStatement(\n  discriminant: t.Expression,\n  cases: t.SwitchCase[],\n): t.SwitchStatement {\n  return {\n    type: TYPE,\n    discriminant,\n    cases,\n  };\n}\n\nexport function isSwitchStatement(\n  node: t.Node | null | undefined,\n): node is t.SwitchStatement {\n  return is(TYPE, node);\n}\n\nexport function assertSwitchStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.SwitchStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'ThrowStatement';\n\nexport function throwStatement(argument: t.Expression): t.ThrowStatement {\n  return {\n    type: TYPE,\n    argument,\n  };\n}\n\nexport function isThrowStatement(\n  node: t.Node | null | undefined,\n): node is t.ThrowStatement {\n  return is(TYPE, node);\n}\n\nexport function assertThrowStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.ThrowStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TryStatement';\n\nexport function tryStatement(\n  block: t.BlockStatement,\n  handler: t.CatchClause | null | undefined = null,\n  finalizer: t.BlockStatement | null | undefined = null,\n): t.TryStatement {\n  return {\n    type: TYPE,\n    block,\n    handler,\n    finalizer,\n  };\n}\n\nexport function isTryStatement(\n  node: t.Node | null | undefined,\n): node is t.TryStatement {\n  return is(TYPE, node);\n}\n\nexport function assertTryStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.TryStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'VariableDeclaration';\n\nexport type VariableDeclarationKind =\n  | 'var'\n  | 'let'\n  | 'const'\n  | 'using'\n  | 'await using';\n\nexport function variableDeclaration(\n  kind: VariableDeclarationKind,\n  declarations: t.VariableDeclarator[],\n): t.VariableDeclaration {\n  return {\n    type: TYPE,\n    kind,\n    declarations,\n  };\n}\n\nexport function isVariableDeclaration(\n  node: t.Node | null | undefined,\n): node is t.VariableDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertVariableDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.VariableDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'WhileStatement';\n\nexport function whileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.WhileStatement {\n  return {\n    type: TYPE,\n    test,\n    body,\n  };\n}\n\nexport function isWhileStatement(\n  node: t.Node | null | undefined,\n): node is t.WhileStatement {\n  return is(TYPE, node);\n}\n\nexport function assertWhileStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.WhileStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'WithStatement';\n\nexport function withStatement(\n  object: t.Expression,\n  body: t.Statement,\n): t.WithStatement {\n  return {\n    type: TYPE,\n    object,\n    body,\n  };\n}\n\nexport function isWithStatement(\n  node: t.Node | null | undefined,\n): node is t.WithStatement {\n  return is(TYPE, node);\n}\n\nexport function assertWithStatement(\n  node: t.Node | null | undefined,\n): asserts node is t.WithStatement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXAttribute';\n\nexport function jsxAttribute(\n  name: t.JSXIdentifier | t.JSXNamespacedName,\n  value:\n    | t.JSXElement\n    | t.JSXFragment\n    | t.StringLiteral\n    | t.JSXExpressionContainer\n    | null = null,\n): t.JSXAttribute {\n  return {\n    type: TYPE,\n    name,\n    value,\n  };\n}\n\nexport function isJSXAttribute(\n  node: t.Node | null | undefined,\n): node is t.JSXAttribute {\n  return is(TYPE, node);\n}\n\nexport function assertJSXAttribute(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXAttribute {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXClosingElement';\n\nexport function jsxClosingElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n): t.JSXClosingElement {\n  return {\n    type: TYPE,\n    name,\n  };\n}\n\nexport function isJSXClosingElement(\n  node: t.Node | null | undefined,\n): node is t.JSXClosingElement {\n  return is(TYPE, node);\n}\n\nexport function assertJSXClosingElement(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXClosingElement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXClosingFragment';\n\nexport function jsxClosingFragment(): t.JSXClosingFragment {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isJSXClosingFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXClosingFragment {\n  return is(TYPE, node);\n}\n\nexport function assertJSXClosingFragment(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXClosingFragment {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXElement';\n\nexport function jsxElement(\n  openingElement: t.JSXOpeningElement,\n  closingElement: t.JSXClosingElement | null | undefined,\n  children: Array<\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  >,\n  selfClosing: boolean | null | undefined = null,\n): t.JSXElement {\n  return {\n    type: TYPE,\n    openingElement,\n    closingElement,\n    children,\n    selfClosing,\n  };\n}\n\nexport function isJSXElement(\n  node: t.Node | null | undefined,\n): node is t.JSXElement {\n  return is(TYPE, node);\n}\n\nexport function assertJSXElement(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXElement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXEmptyExpression';\n\nexport function jsxEmptyExpression(): t.JSXEmptyExpression {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isJSXEmptyExpression(\n  node: t.Node | null | undefined,\n): node is t.JSXEmptyExpression {\n  return is(TYPE, node);\n}\n\nexport function assertJSXEmptyExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXEmptyExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXExpressionContainer';\n\nexport function jsxExpressionContainer(\n  expression: t.Expression | t.JSXEmptyExpression,\n): t.JSXExpressionContainer {\n  return {\n    type: TYPE,\n    expression,\n  };\n}\n\nexport function isJSXExpressionContainer(\n  node: t.Node | null | undefined,\n): node is t.JSXExpressionContainer {\n  return is(TYPE, node);\n}\n\nexport function assertJSXExpressionContainer(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXExpressionContainer {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXFragment';\n\nexport function jsxFragment(\n  openingFragment: t.JSXOpeningFragment,\n  closingFragment: t.JSXClosingFragment,\n  children: Array<\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  >,\n): t.JSXFragment {\n  return {\n    type: TYPE,\n    openingFragment,\n    closingFragment,\n    children,\n  };\n}\n\nexport function isJSXFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXFragment {\n  return is(TYPE, node);\n}\n\nexport function assertJSXFragment(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXFragment {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXIdentifier';\n\nexport function jsxIdentifier(name: string): t.JSXIdentifier {\n  return {\n    type: TYPE,\n    name,\n  };\n}\n\nexport function isJSXIdentifier(\n  node: t.Node | null | undefined,\n): node is t.JSXIdentifier {\n  return is(TYPE, node);\n}\n\nexport function assertJSXIdentifier(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXIdentifier {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXMemberExpression';\n\nexport function jsxMemberExpression(\n  object: t.JSXMemberExpression | t.JSXIdentifier,\n  property: t.JSXIdentifier,\n): t.JSXMemberExpression {\n  return {\n    type: TYPE,\n    object,\n    property,\n  };\n}\n\nexport function isJSXMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.JSXMemberExpression {\n  return is(TYPE, node);\n}\n\nexport function assertJSXMemberExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXMemberExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXNamespacedName';\n\nexport function jsxNamespacedName(\n  namespace: t.JSXIdentifier,\n  name: t.JSXIdentifier,\n): t.JSXNamespacedName {\n  return {\n    type: TYPE,\n    namespace,\n    name,\n  };\n}\n\nexport function isJSXNamespacedName(\n  node: t.Node | null | undefined,\n): node is t.JSXNamespacedName {\n  return is(TYPE, node);\n}\n\nexport function assertJSXNamespacedName(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXNamespacedName {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXOpeningElement';\n\nexport function jsxOpeningElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n  attributes: Array<t.JSXAttribute | t.JSXSpreadAttribute>,\n  selfClosing = false,\n): t.JSXOpeningElement {\n  return {\n    type: TYPE,\n    name,\n    attributes,\n    selfClosing,\n  };\n}\n\nexport function isJSXOpeningElement(\n  node: t.Node | null | undefined,\n): node is t.JSXOpeningElement {\n  return is(TYPE, node);\n}\n\nexport function assertJSXOpeningElement(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXOpeningElement {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXOpeningFragment';\n\nexport function jsxOpeningFragment(): t.JSXOpeningFragment {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isJSXOpeningFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXOpeningFragment {\n  return is(TYPE, node);\n}\n\nexport function assertJSXOpeningFragment(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXOpeningFragment {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXSpreadAttribute';\n\nexport function jsxSpreadAttribute(\n  argument: t.Expression,\n): t.JSXSpreadAttribute {\n  return {\n    type: TYPE,\n    argument,\n  };\n}\n\nexport function isJSXSpreadAttribute(\n  node: t.Node | null | undefined,\n): node is t.JSXSpreadAttribute {\n  return is(TYPE, node);\n}\n\nexport function assertJSXSpreadAttribute(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXSpreadAttribute {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXSpreadChild';\n\nexport function jsxSpreadChild(\n  expression: t.Expression,\n): t.JSXSpreadChild {\n  return {\n    type: TYPE,\n    expression,\n  };\n}\n\nexport function isJSXSpreadChild(\n  node: t.Node | null | undefined,\n): node is t.JSXSpreadChild {\n  return is(TYPE, node);\n}\n\nexport function assertJSXSpreadChild(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXSpreadChild {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../assert-node-type';\nimport { is } from '../../is-node-type';\n\nconst TYPE = 'JSXText';\n\nexport function jsxText(value: string): t.JSXText {\n  return {\n    type: TYPE,\n    value,\n  };\n}\n\nexport function isJSXText(node: t.Node | null | undefined): node is t.JSXText {\n  return is(TYPE, node);\n}\n\nexport function assertJSXText(\n  node: t.Node | null | undefined,\n): asserts node is t.JSXText {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSAsExpression';\n\nexport function tsAsExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSAsExpression {\n  return {\n    type: TYPE,\n    expression,\n    typeAnnotation,\n  };\n}\n\nexport function isTSAsExpression(\n  node: t.Node | null | undefined,\n): node is t.TSAsExpression {\n  return is(TYPE, node);\n}\n\nexport function assertTSAsExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.TSAsExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSInstantiationExpression';\n\nexport function tsInstantiationExpression(\n  expression: t.Expression,\n  typeParameters: t.TSTypeParameterInstantiation | null | undefined = null,\n): t.TSInstantiationExpression {\n  return {\n    type: TYPE,\n    expression,\n    typeParameters,\n  };\n}\n\nexport function isTSInstantiationExpression(\n  node: t.Node | null | undefined,\n): node is t.TSInstantiationExpression {\n  return is(TYPE, node);\n}\n\nexport function assertTSInstantiationExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.TSInstantiationExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSNonNullExpression';\n\nexport function tsNonNullExpression(\n  expression: t.Expression,\n): t.TSNonNullExpression {\n  return {\n    type: TYPE,\n    expression,\n  };\n}\n\nexport function isTSNonNullExpression(\n  node: t.Node | null | undefined,\n): node is t.TSNonNullExpression {\n  return is(TYPE, node);\n}\n\nexport function assertTSNonNullExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.TSNonNullExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSSatisfiesExpression';\n\nexport function tsSatisfiesExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSSatisfiesExpression {\n  return {\n    type: TYPE,\n    expression,\n    typeAnnotation,\n  };\n}\n\nexport function isTSSatisfiesExpression(\n  node: t.Node | null | undefined,\n): node is t.TSSatisfiesExpression {\n  return is(TYPE, node);\n}\n\nexport function assertTSSatisfiesExpression(\n  node: t.Node | null | undefined,\n): asserts node is t.TSSatisfiesExpression {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeAssertion';\n\nexport function tsTypeAssertion(\n  typeAnnotation: t.TSType,\n  expression: t.Expression,\n): t.TSTypeAssertion {\n  return {\n    type: TYPE,\n    typeAnnotation,\n    expression,\n  };\n}\n\nexport function isTSTypeAssertion(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAssertion {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeAssertion(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeAssertion {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSAnyKeyword';\n\nexport function tsAnyKeyword(): t.TSAnyKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSAnyKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSAnyKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSAnyKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSAnyKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSArrayType';\n\nexport function tsArrayType(elementType: t.TSType): t.TSArrayType {\n  return {\n    type: TYPE,\n    elementType,\n  };\n}\n\nexport function isTSArrayType(\n  node: t.Node | null | undefined,\n): node is t.TSArrayType {\n  return is(TYPE, node);\n}\n\nexport function assertTSArrayType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSArrayType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSBigIntKeyword';\n\nexport function tsBigIntKeyword(): t.TSBigIntKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSBigIntKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSBigIntKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSBigIntKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSBigIntKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSBooleanKeyword';\n\nexport function tsBooleanKeyword(): t.TSBooleanKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSBooleanKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSBooleanKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSBooleanKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSBooleanKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSCallSignatureDeclaration';\n\nexport function tsCallSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null | undefined = null,\n): t.TSCallSignatureDeclaration {\n  return {\n    type: TYPE,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  };\n}\n\nexport function isTSCallSignatureDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSCallSignatureDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSCallSignatureDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSCallSignatureDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSConditionalType';\n\nexport function tsConditionalType(\n  checkType: t.TSType,\n  extendsType: t.TSType,\n  trueType: t.TSType,\n  falseType: t.TSType,\n): t.TSConditionalType {\n  return {\n    type: TYPE,\n    checkType,\n    extendsType,\n    trueType,\n    falseType,\n  };\n}\n\nexport function isTSConditionalType(\n  node: t.Node | null | undefined,\n): node is t.TSConditionalType {\n  return is(TYPE, node);\n}\n\nexport function assertTSConditionalType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSConditionalType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSConstructSignatureDeclaration';\n\nexport function tsConstructSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null | undefined = null,\n): t.TSConstructSignatureDeclaration {\n  return {\n    type: TYPE,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  };\n}\n\nexport function isTSConstructSignatureDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSConstructSignatureDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSConstructSignatureDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSConstructSignatureDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSConstructorType';\n\nexport function tsConstructorType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null | undefined = null,\n): t.TSConstructorType {\n  return {\n    type: TYPE,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  };\n}\n\nexport function isTSConstructorType(\n  node: t.Node | null | undefined,\n): node is t.TSConstructorType {\n  return is(TYPE, node);\n}\n\nexport function assertTSConstructorType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSConstructorType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSDeclareMethod';\n\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | t.Noop | null | undefined,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  returnType: t.TSTypeAnnotation | t.Noop | null | undefined = null,\n): t.TSDeclareMethod {\n  return {\n    type: TYPE,\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType,\n  };\n}\n\nexport function isTSDeclareMethod(\n  node: t.Node | null | undefined,\n): node is t.TSDeclareMethod {\n  return is(TYPE, node);\n}\n\nexport function assertTSDeclareMethod(\n  node: t.Node | null | undefined,\n): asserts node is t.TSDeclareMethod {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSExpressionWithTypeArguments';\n\nexport function tsExpressionWithTypeArguments(\n  expression: t.TSEntityName,\n  typeParameters: t.TSTypeParameterInstantiation | null | undefined = null,\n): t.TSExpressionWithTypeArguments {\n  return {\n    type: TYPE,\n    expression,\n    typeParameters,\n  };\n}\n\nexport function isTSExpressionWithTypeArguments(\n  node: t.Node | null | undefined,\n): node is t.TSExpressionWithTypeArguments {\n  return is(TYPE, node);\n}\n\nexport function assertTSExpressionWithTypeArguments(\n  node: t.Node | null | undefined,\n): asserts node is t.TSExpressionWithTypeArguments {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSFunctionType';\n\nexport function tsFunctionType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null | undefined = null,\n): t.TSFunctionType {\n  return {\n    type: TYPE,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  };\n}\n\nexport function isTSFunctionType(\n  node: t.Node | null | undefined,\n): node is t.TSFunctionType {\n  return is(TYPE, node);\n}\n\nexport function assertTSFunctionType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSFunctionType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSImportType';\n\nexport function tsImportType(\n  argument: t.StringLiteral,\n  qualifier: t.TSEntityName | null | undefined = null,\n  typeParameters: t.TSTypeParameterInstantiation | null | undefined = null,\n): t.TSImportType {\n  return {\n    type: TYPE,\n    argument,\n    qualifier,\n    typeParameters,\n  };\n}\n\nexport function isTSImportType(\n  node: t.Node | null | undefined,\n): node is t.TSImportType {\n  return is(TYPE, node);\n}\n\nexport function assertTSImportType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSImportType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSIndexSignature';\n\nexport function tsIndexSignature(\n  parameters: t.Identifier[],\n  typeAnnotation: t.TSTypeAnnotation | null | undefined = null,\n): t.TSIndexSignature {\n  return {\n    type: TYPE,\n    parameters,\n    typeAnnotation,\n  };\n}\n\nexport function isTSIndexSignature(\n  node: t.Node | null | undefined,\n): node is t.TSIndexSignature {\n  return is(TYPE, node);\n}\n\nexport function assertTSIndexSignature(\n  node: t.Node | null | undefined,\n): asserts node is t.TSIndexSignature {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSIndexedAccessType';\n\nexport function tsIndexedAccessType(\n  objectType: t.TSType,\n  indexType: t.TSType,\n): t.TSIndexedAccessType {\n  return {\n    type: TYPE,\n    objectType,\n    indexType,\n  };\n}\n\nexport function isTSIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.TSIndexedAccessType {\n  return is(TYPE, node);\n}\n\nexport function assertTSIndexedAccessType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSIndexedAccessType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSInferType';\n\nexport function tsInferType(typeParameter: t.TSTypeParameter): t.TSInferType {\n  return {\n    type: TYPE,\n    typeParameter,\n  };\n}\n\nexport function isTSInferType(\n  node: t.Node | null | undefined,\n): node is t.TSInferType {\n  return is(TYPE, node);\n}\n\nexport function assertTSInferType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSInferType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSIntersectionType';\n\nexport function tsIntersectionType(types: t.TSType[]): t.TSIntersectionType {\n  return {\n    type: TYPE,\n    types,\n  };\n}\n\nexport function isTSIntersectionType(\n  node: t.Node | null | undefined,\n): node is t.TSIntersectionType {\n  return is(TYPE, node);\n}\n\nexport function assertTSIntersectionType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSIntersectionType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSIntrinsicKeyword';\n\nexport function tsIntrinsicKeyword(): t.TSIntrinsicKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSIntrinsicKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSIntrinsicKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSIntrinsicKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSIntrinsicKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSLiteralType';\n\nexport function tsLiteralType(\n  literal:\n    | t.NumericLiteral\n    | t.StringLiteral\n    | t.BooleanLiteral\n    | t.BigIntLiteral\n    | t.TemplateLiteral\n    | t.UnaryExpression,\n): t.TSLiteralType {\n  return {\n    type: TYPE,\n    literal,\n  };\n}\n\nexport function isTSLiteralType(\n  node: t.Node | null | undefined,\n): node is t.TSLiteralType {\n  return is(TYPE, node);\n}\n\nexport function assertTSLiteralType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSLiteralType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSMappedType';\n\nexport function tsMappedType(\n  typeParameter: t.TSTypeParameter,\n  typeAnnotation: t.TSType | null | undefined = null,\n  nameType: t.TSType | null | undefined = null,\n): t.TSMappedType {\n  return {\n    type: TYPE,\n    typeParameter,\n    typeAnnotation,\n    nameType,\n  };\n}\n\nexport function isTSMappedType(\n  node: t.Node | null | undefined,\n): node is t.TSMappedType {\n  return is(TYPE, node);\n}\n\nexport function assertTSMappedType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSMappedType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSMethodSignature';\n\nexport type TSMethodSignatureKind = 'get' | 'set' | 'method';\n\nexport function tsMethodSignature(\n  key: t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  parameters: Array<\n    t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement\n  >,\n  typeAnnotation: t.TSTypeAnnotation | null | undefined = null,\n  kind: TSMethodSignatureKind = 'method',\n): t.TSMethodSignature {\n  return {\n    type: TYPE,\n    key,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n    kind,\n  };\n}\n\nexport function isTSMethodSignature(\n  node: t.Node | null | undefined,\n): node is t.TSMethodSignature {\n  return is(TYPE, node);\n}\n\nexport function assertTSMethodSignature(\n  node: t.Node | null | undefined,\n): asserts node is t.TSMethodSignature {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSModuleBlock';\n\nexport function tsModuleBlock(body: t.Statement[]): t.TSModuleBlock {\n  return {\n    type: TYPE,\n    body,\n  };\n}\n\nexport function isTSModuleBlock(\n  node: t.Node | null | undefined,\n): node is t.TSModuleBlock {\n  return is(TYPE, node);\n}\n\nexport function assertTSModuleBlock(\n  node: t.Node | null | undefined,\n): asserts node is t.TSModuleBlock {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSNamedTupleMember';\n\nexport function tsNamedTupleMember(\n  label: t.Identifier,\n  elementType: t.TSType,\n  optional = false,\n): t.TSNamedTupleMember {\n  return {\n    type: TYPE,\n    label,\n    elementType,\n    optional,\n  };\n}\n\nexport function isTSNamedTupleMember(\n  node: t.Node | null | undefined,\n): node is t.TSNamedTupleMember {\n  return is(TYPE, node);\n}\n\nexport function assertTSNamedTupleMember(\n  node: t.Node | null | undefined,\n): asserts node is t.TSNamedTupleMember {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSNeverKeyword';\n\nexport function tsNeverKeyword(): t.TSNeverKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSNeverKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNeverKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSNeverKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSNeverKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSNullKeyword';\n\nexport function tsNullKeyword(): t.TSNullKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSNullKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNullKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSNullKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSNullKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSNumberKeyword';\n\nexport function tsNumberKeyword(): t.TSNumberKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSNumberKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNumberKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSNumberKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSNumberKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSObjectKeyword';\n\nexport function tsObjectKeyword(): t.TSObjectKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSObjectKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSObjectKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSObjectKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSObjectKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSOptionalType';\n\nexport function tsOptionalType(typeAnnotation: t.TSType): t.TSOptionalType {\n  return {\n    type: TYPE,\n    typeAnnotation,\n  };\n}\n\nexport function isTSOptionalType(\n  node: t.Node | null | undefined,\n): node is t.TSOptionalType {\n  return is(TYPE, node);\n}\n\nexport function assertTSOptionalType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSOptionalType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSParameterProperty';\n\nexport function tsParameterProperty(\n  parameter: t.Identifier | t.AssignmentPattern,\n): t.TSParameterProperty {\n  return {\n    type: TYPE,\n    parameter,\n  };\n}\n\nexport function isTSParameterProperty(\n  node: t.Node | null | undefined,\n): node is t.TSParameterProperty {\n  return is(TYPE, node);\n}\n\nexport function assertTSParameterProperty(\n  node: t.Node | null | undefined,\n): asserts node is t.TSParameterProperty {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSParenthesizedType';\n\nexport function tsParenthesizedType(\n  typeAnnotation: t.TSType,\n): t.TSParenthesizedType {\n  return {\n    type: TYPE,\n    typeAnnotation,\n  };\n}\n\nexport function isTSParenthesizedType(\n  node: t.Node | null | undefined,\n): node is t.TSParenthesizedType {\n  return is(TYPE, node);\n}\n\nexport function assertTSParenthesizedType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSParenthesizedType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSPropertySignature';\n\nexport type TSPropertySignature = 'get' | 'set' | null;\n\nexport function tsPropertySignature(\n  key: t.Expression,\n  typeAnnotation: t.TSTypeAnnotation | null | undefined = null,\n  kind: TSPropertySignature = null,\n): t.TSPropertySignature {\n  return {\n    type: TYPE,\n    key,\n    typeAnnotation,\n    kind: kind as unknown as 'set', // no nulls lul,\n  };\n}\n\nexport function isTSPropertySignature(\n  node: t.Node | null | undefined,\n): node is t.TSPropertySignature {\n  return is(TYPE, node);\n}\n\nexport function assertTSPropertySignature(\n  node: t.Node | null | undefined,\n): asserts node is t.TSPropertySignature {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSQualifiedName';\n\nexport function tsQualifiedName(\n  left: t.TSEntityName,\n  right: t.Identifier,\n): t.TSQualifiedName {\n  return {\n    type: TYPE,\n    left,\n    right,\n  };\n}\n\nexport function isTSQualifiedName(\n  node: t.Node | null | undefined,\n): node is t.TSQualifiedName {\n  return is(TYPE, node);\n}\n\nexport function assertTSQualifiedName(\n  node: t.Node | null | undefined,\n): asserts node is t.TSQualifiedName {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSRestType';\n\nexport function tsRestType(typeAnnotation: t.TSType): t.TSRestType {\n  return {\n    type: TYPE,\n    typeAnnotation,\n  };\n}\n\nexport function isTSRestType(\n  node: t.Node | null | undefined,\n): node is t.TSRestType {\n  return is(TYPE, node);\n}\n\nexport function assertTSRestType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSRestType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSStringKeyword';\n\nexport function tsStringKeyword(): t.TSStringKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSStringKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSStringKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSStringKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSStringKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSSymbolKeyword';\n\nexport function tsSymbolKeyword(): t.TSSymbolKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSSymbolKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSSymbolKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSSymbolKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSSymbolKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSThisType';\n\nexport function tsThisType(): t.TSThisType {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSThisType(\n  node: t.Node | null | undefined,\n): node is t.TSThisType {\n  return is(TYPE, node);\n}\n\nexport function assertTSThisType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSThisType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTupleType';\n\nexport function tsTupleType(\n  elementTypes: Array<t.TSType | t.TSNamedTupleMember>,\n): t.TSTupleType {\n  return {\n    type: TYPE,\n    elementTypes,\n  };\n}\n\nexport function isTSTupleType(\n  node: t.Node | null | undefined,\n): node is t.TSTupleType {\n  return is(TYPE, node);\n}\n\nexport function assertTSTupleType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTupleType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeAnnotation';\n\nexport function tsTypeAnnotation(typeAnnotation: t.TSType): t.TSTypeAnnotation {\n  return {\n    type: TYPE,\n    typeAnnotation,\n  };\n}\n\nexport function isTSTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAnnotation {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeAnnotation(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeAnnotation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeLiteral';\n\nexport function tsTypeLiteral(members: t.TSTypeElement[]): t.TSTypeLiteral {\n  return {\n    type: TYPE,\n    members,\n  };\n}\n\nexport function isTSTypeLiteral(\n  node: t.Node | null | undefined,\n): node is t.TSTypeLiteral {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeLiteral(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeLiteral {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeOperator';\n\nexport function tsTypeOperator(\n  typeAnnotation: t.TSType,\n  operator = 'keyof',\n): t.TSTypeOperator {\n  return {\n    type: TYPE,\n    typeAnnotation,\n    operator,\n  };\n}\n\nexport function isTSTypeOperator(\n  node: t.Node | null | undefined,\n): node is t.TSTypeOperator {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeOperator(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeOperator {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeParameter';\n\nexport function tsTypeParameter(\n  constraint: t.TSType | null | undefined,\n  _default: t.TSType | null | undefined,\n  name: string,\n): t.TSTypeParameter {\n  return {\n    type: TYPE,\n    constraint,\n    default: _default,\n    name,\n  };\n}\n\nexport function isTSTypeParameter(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameter {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeParameter(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeParameter {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeParameterDeclaration';\n\nexport function tsTypeParameterDeclaration(\n  params: t.TSTypeParameter[],\n): t.TSTypeParameterDeclaration {\n  return {\n    type: TYPE,\n    params,\n  };\n}\n\nexport function isTSTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameterDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeParameterDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeParameterInstantiation';\n\nexport function tsTypeParameterInstantiation(\n  params: t.TSType[],\n): t.TSTypeParameterInstantiation {\n  return {\n    type: TYPE,\n    params,\n  };\n}\n\nexport function isTSTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameterInstantiation {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeParameterInstantiation {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypePredicate';\n\nexport function tsTypePredicate(\n  parameterName: t.Identifier | t.TSThisType,\n  typeAnnotation: t.TSTypeAnnotation | null | undefined = null,\n  asserts: boolean | null | undefined = null,\n): t.TSTypePredicate {\n  return {\n    type: TYPE,\n    parameterName,\n    typeAnnotation,\n    asserts,\n  };\n}\n\nexport function isTSTypePredicate(\n  node: t.Node | null | undefined,\n): node is t.TSTypePredicate {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypePredicate(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypePredicate {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeQuery';\n\nexport function tsTypeQuery(\n  exprName: t.TSEntityName | t.TSImportType,\n  typeParameters: t.TSTypeParameterInstantiation | null | undefined = null,\n): t.TSTypeQuery {\n  return {\n    type: TYPE,\n    exprName,\n    typeParameters,\n  };\n}\n\nexport function isTSTypeQuery(\n  node: t.Node | null | undefined,\n): node is t.TSTypeQuery {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeQuery(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeQuery {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeReference';\n\nexport function tsTypeReference(\n  typeName: t.TSEntityName,\n  typeParameters: t.TSTypeParameterInstantiation | null | undefined = null,\n): t.TSTypeReference {\n  return {\n    type: TYPE,\n    typeName,\n    typeParameters,\n  };\n}\n\nexport function isTSTypeReference(\n  node: t.Node | null | undefined,\n): node is t.TSTypeReference {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeReference(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeReference {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSUndefinedKeyword';\n\nexport function tsUndefinedKeyword(): t.TSUndefinedKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSUndefinedKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSUndefinedKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSUndefinedKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSUndefinedKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSUnionType';\n\nexport function tsUnionType(types: t.TSType[]): t.TSUnionType {\n  return {\n    type: TYPE,\n    types,\n  };\n}\n\nexport function isTSUnionType(\n  node: t.Node | null | undefined,\n): node is t.TSUnionType {\n  return is(TYPE, node);\n}\n\nexport function assertTSUnionType(\n  node: t.Node | null | undefined,\n): asserts node is t.TSUnionType {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSUnknownKeyword';\n\nexport function tsUnknownKeyword(): t.TSUnknownKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSUnknownKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSUnknownKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSUnknownKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSUnknownKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSVoidKeyword';\n\nexport function tsVoidKeyword(): t.TSVoidKeyword {\n  return {\n    type: TYPE,\n  };\n}\n\nexport function isTSVoidKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSVoidKeyword {\n  return is(TYPE, node);\n}\n\nexport function assertTSVoidKeyword(\n  node: t.Node | null | undefined,\n): asserts node is t.TSVoidKeyword {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSDeclareFunction';\n\nexport function tsDeclareFunction(\n  id: t.Identifier | null | undefined,\n  typeParameters: t.TSTypeParameterDeclaration | t.Noop | null | undefined,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  returnType?: t.TSTypeAnnotation | t.Noop | null,\n): t.TSDeclareFunction {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    params,\n    returnType,\n  };\n}\n\nexport function isTSDeclareFunction(\n  node: t.Node | null | undefined,\n): node is t.TSDeclareFunction {\n  return is(TYPE, node);\n}\n\nexport function assertTSDeclareFunction(\n  node: t.Node | null | undefined,\n): asserts node is t.TSDeclareFunction {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSEnumDeclaration';\n\nexport function tsEnumDeclaration(\n  id: t.Identifier,\n  members: t.TSEnumMember[],\n): t.TSEnumDeclaration {\n  return {\n    type: TYPE,\n    id,\n    members,\n  };\n}\n\nexport function isTSEnumDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSEnumDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSEnumDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSEnumDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSExportAssignment';\n\nexport function tsExportAssignment(\n  expression: t.Expression,\n): t.TSExportAssignment {\n  return {\n    type: TYPE,\n    expression,\n  };\n}\n\nexport function isTSExportAssignment(\n  node: t.Node | null | undefined,\n): node is t.TSExportAssignment {\n  return is(TYPE, node);\n}\n\nexport function assertTSExportAssignment(\n  node: t.Node | null | undefined,\n): asserts node is t.TSExportAssignment {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSImportEqualsDeclaration';\n\nexport function tsImportEqualsDeclaration(\n  id: t.Identifier,\n  moduleReference: t.TSEntityName | t.TSExternalModuleReference,\n): t.TSImportEqualsDeclaration {\n  return {\n    type: TYPE,\n    id,\n    moduleReference,\n    isExport: false,\n  };\n}\n\nexport function isTSImportEqualsDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSImportEqualsDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSImportEqualsDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSImportEqualsDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSInterfaceDeclaration';\n\nexport function tsInterfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  interfaceExtends: t.TSExpressionWithTypeArguments[] | null | undefined,\n  body: t.TSInterfaceBody,\n): t.TSInterfaceDeclaration {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    extends: interfaceExtends,\n    body,\n  };\n}\n\nexport function isTSInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSInterfaceDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSModuleDeclaration';\n\nexport function tsModuleDeclaration(\n  id: t.Identifier | t.StringLiteral,\n  body: t.TSModuleBlock | t.TSModuleDeclaration,\n): t.TSModuleDeclaration {\n  return {\n    type: TYPE,\n    id,\n    body,\n  };\n}\n\nexport function isTSModuleDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSModuleDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSModuleDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSModuleDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSNamespaceExportDeclaration';\n\nexport function tsNamespaceExportDeclaration(\n  id: t.Identifier,\n): t.TSNamespaceExportDeclaration {\n  return {\n    type: TYPE,\n    id,\n  };\n}\n\nexport function isTSNamespaceExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSNamespaceExportDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSNamespaceExportDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSNamespaceExportDeclaration {\n  assert(TYPE, node);\n}\n", "import type * as t from '@babel/types';\nimport { assert } from '../../../assert-node-type';\nimport { is } from '../../../is-node-type';\n\nconst TYPE = 'TSTypeAliasDeclaration';\n\nexport function tsTypeAliasDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  typeAnnotation: t.TSType,\n): t.TSTypeAliasDeclaration {\n  return {\n    type: TYPE,\n    id,\n    typeParameters,\n    typeAnnotation,\n  };\n}\n\nexport function isTSTypeAliasDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAliasDeclaration {\n  return is(TYPE, node);\n}\n\nexport function assertTSTypeAliasDeclaration(\n  node: t.Node | null | undefined,\n): asserts node is t.TSTypeAliasDeclaration {\n  assert(TYPE, node);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEO,SAAS,YACd,MACA,MACA,UACG;AACH,QAA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",
  "names": ["typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "interfaceExtends", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "variance", "TYPE", "TYPE", "variance", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "interfaceExtends", "TYPE", "TYPE", "TYPE", "TYPE", "interfaceExtends", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "interfaceExtends", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "typeAnnotation", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "typeAnnotation", "TYPE", "typeAnnotation", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "typeAnnotation", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "TYPE", "interfaceExtends", "TYPE", "TYPE", "TYPE", "typeAnnotation"]
}
