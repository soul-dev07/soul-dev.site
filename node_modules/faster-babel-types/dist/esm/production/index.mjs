function wr(e,r,o){let i=`${r}Comments`;return e[i]?r==="leading"?e[i]=o.concat(e[i]):e[i].push.apply(e[i],o):e[i]=o,e}function hr(e,r,o){return wr(e,r,[o])}function t(e,r){return r!=null&&r.type===e}function n(e,r){if(t(e,r))throw new Error('Expected type "'+e+'" but instead got "'+r.type+'".')}var l="TypeCastExpression";function jr(e,r){return{type:l,expression:e,typeAnnotation:r}}function Kr(e){return t(l,e)}function Rr(e){n(l,e)}var d="AnyTypeAnnotation";function Wr(){return{type:d}}function Qr(e){return t(d,e)}function zr(e){n(d,e)}var f="ArrayTypeAnnotation";function Hr(e){return{type:f,elementType:e}}function Zr(e){return t(f,e)}function eo(e){n(f,e)}var m="BooleanLiteralTypeAnnotation";function oo(e){return{type:m,value:e}}function io(e){return t(m,e)}function so(e){n(m,e)}var c="BooleanTypeAnnotation";function lo(){return{type:c}}function fo(e){return t(c,e)}function mo(e){n(c,e)}var y="EmptyTypeAnnotation";function To(){return{type:y}}function So(e){return t(y,e)}function Eo(e){n(y,e)}var x="EnumBooleanBody";function Ao(e){return{type:x,members:e,explicitType:!1,hasUnknownMembers:!1}}function Io(e){return t(x,e)}function Do(e){n(x,e)}var T="EnumBooleanMember";function wo(e){return{type:T,id:e,init:null}}function ho(e){return t(T,e)}function Mo(e){n(T,e)}var S="EnumDefaultedMember";function Fo(e){return{type:S,id:e}}function Jo(e){return t(S,e)}function Xo(e){n(S,e)}var E="EnumNumberBody";function Vo(e){return{type:E,members:e,explicitType:!1,hasUnknownMembers:!1}}function ko(e){return t(E,e)}function vo(e){n(E,e)}var b="EnumNumberMember";function Qo(e,r){return{type:b,id:e,init:r}}function zo(e){return t(b,e)}function Go(e){n(b,e)}var N="EnumStringBody";function Zo(e){return{type:N,members:e,explicitType:!1,hasUnknownMembers:!1}}function ei(e){return t(N,e)}function ti(e){n(N,e)}var P="EnumStringMember";function ii(e,r){return{type:P,id:e,init:r}}function si(e){return t(P,e)}function pi(e){n(P,e)}var A="EnumSymbolBody";function di(e){return{type:A,members:e,hasUnknownMembers:!1}}function fi(e){return t(A,e)}function mi(e){n(A,e)}var I="ExistsTypeAnnotation";function Ti(){return{type:I}}function Si(e){return t(I,e)}function Ei(e){n(I,e)}var D="FunctionTypeAnnotation";function Ai(e,r,o,i){return{type:D,typeParameters:e,params:r,rest:o,returnType:i}}function Ii(e){return t(D,e)}function Di(e){n(D,e)}var g="FunctionTypeParam";function wi(e,r){return{type:g,name:e,typeAnnotation:r}}function hi(e){return t(g,e)}function Mi(e){n(g,e)}var Y="GenericTypeAnnotation";function Fi(e,r=null){return{type:Y,id:e,typeParameters:r}}function Ji(e){return t(Y,e)}function Xi(e){n(Y,e)}var C="IndexedAccessType";function Vi(e,r){return{type:C,objectType:e,indexType:r}}function ki(e){return t(C,e)}function vi(e){n(C,e)}var w="InterfaceExtends";function Qi(e,r=null){return{type:w,id:e,typeParameters:r}}function zi(e){return t(w,e)}function Gi(e){n(w,e)}var h="InterfaceTypeAnnotation";function Zi(e,r){return{type:h,extends:e,body:r}}function es(e){return t(h,e)}function ts(e){n(h,e)}var M="IntersectionTypeAnnotation";function is(e){return{type:M,types:e}}function ss(e){return t(M,e)}function ps(e){n(M,e)}var L="MixedTypeAnnotation";function ds(){return{type:L}}function fs(e){return t(L,e)}function ms(e){n(L,e)}var B="NullLiteralTypeAnnotation";function Ts(){return{type:B}}function Ss(e){return t(B,e)}function Es(e){n(B,e)}var O="NullableTypeAnnotation";function As(e){return{type:O,typeAnnotation:e}}function Is(e){return t(O,e)}function Ds(e){n(O,e)}var F="NumberLiteralTypeAnnotation";function ws(e){return{type:F,value:e}}function hs(e){return t(F,e)}function Ms(e){n(F,e)}var J="NumberTypeAnnotation";function Fs(){return{type:J}}function Js(e){return t(J,e)}function Xs(e){n(J,e)}var X="ObjectTypeAnnotation";function Vs(e,r=[],o=[],i=[],s=!1){return{type:X,properties:e,indexers:r,callProperties:o,internalSlots:i,exact:s}}function ks(e){return t(X,e)}function vs(e){n(X,e)}var j="ObjectTypeCallProperty";function Qs(e){return{type:j,value:e,static:!1}}function zs(e){return t(j,e)}function Gs(e){n(j,e)}var K="ObjectTypeIndexer";function Zs(e,r,o,i=null){return{type:K,id:e,key:r,value:o,variance:i,static:!1}}function ep(e){return t(K,e)}function tp(e){n(K,e)}var R="ObjectTypeInternalSlot";function ip(e,r,o,i,s){return{type:R,id:e,value:r,optional:o,static:i,method:s}}function sp(e){return t(R,e)}function pp(e){n(R,e)}var V="ObjectTypeProperty";function dp(e,r,o=null){return{type:V,key:e,value:r,variance:o,kind:"init",method:!1,optional:!1,proto:!1,static:!1}}function fp(e){return t(V,e)}function mp(e){n(V,e)}var k="ObjectTypeSpreadProperty";function Tp(e){return{type:k,argument:e}}function Sp(e){return t(k,e)}function Ep(e){n(k,e)}var v="OptionalIndexedAccessType";function Ap(e,r){return{type:v,objectType:e,indexType:r,optional:!1}}function Ip(e){return t(v,e)}function Dp(e){n(v,e)}var U="QualifiedTypeIdentifier";function wp(e,r){return{type:U,id:e,qualification:r}}function hp(e){return t(U,e)}function Mp(e){n(U,e)}var q="StringLiteralTypeAnnotation";function Fp(e){return{type:q,value:e}}function Jp(e){return t(q,e)}function Xp(e){n(q,e)}var W="StringTypeAnnotation";function Vp(){return{type:W}}function kp(e){return t(W,e)}function vp(e){n(W,e)}var Q="SymbolTypeAnnotation";function Qp(){return{type:Q}}function zp(e){return t(Q,e)}function Gp(e){n(Q,e)}var z="ThisTypeAnnotation";function Zp(){return{type:z}}function ea(e){return t(z,e)}function ta(e){n(z,e)}var G="TupleTypeAnnotation";function ia(e){return{type:G,types:e}}function sa(e){return t(G,e)}function pa(e){n(G,e)}var _="TypeAnnotation";function da(e){return{type:_,typeAnnotation:e}}function fa(e){return t(_,e)}function ma(e){n(_,e)}var $="TypeofTypeAnnotation";function Ta(e){return{type:$,argument:e}}function Sa(e){return t($,e)}function Ea(e){n($,e)}var H="UnionTypeAnnotation";function Aa(e){return{type:H,types:e}}function Ia(e){return t(H,e)}function Da(e){n(H,e)}var Z="Variance";function wa(e){return{type:Z,kind:e}}function ha(e){return t(Z,e)}function Ma(e){n(Z,e)}var ee="VoidTypeAnnotation";function Fa(){return{type:ee}}function Ja(e){return t(ee,e)}function Xa(e){n(ee,e)}var te="DeclareClass";function Lu(e,r,o,i){return{type:te,id:e,typeParameters:r,extends:o,body:i}}function Bu(e){return t(te,e)}function Ou(e){n(te,e)}var ne="DeclareExportAllDeclaration";function ju(e){return{type:ne,source:e}}function Ku(e){return t(ne,e)}function Ru(e){n(ne,e)}var re="DeclareExportDeclaration";function Uu(e,r,o){return{type:re,declaration:e,specifiers:r,source:o}}function qu(e){return t(re,e)}function Wu(e){n(re,e)}var oe="DeclareFunction";function _u(e){return{type:oe,id:e}}function $u(e){return t(oe,e)}function Hu(e){n(oe,e)}var ie="DeclareInterface";function nl(e,r,o,i){return{type:ie,id:e,typeParameters:r,extends:o,body:i}}function rl(e){return t(ie,e)}function ol(e){n(ie,e)}var se="DeclareModule";function al(e,r,o){return{type:se,id:e,body:r,kind:o}}function ul(e){return t(se,e)}function ll(e){n(se,e)}var pe="DeclareModuleExports";function cl(e){return{type:pe,typeAnnotation:e}}function yl(e){return t(pe,e)}function xl(e){n(pe,e)}var ae="DeclareOpaqueType";function bl(e,r,o){return{type:ae,id:e,typeParameters:r,supertype:o}}function Nl(e){return t(ae,e)}function Pl(e){n(ae,e)}var ue="DeclareTypeAlias";function gl(e,r,o){return{type:ue,id:e,typeParameters:r,right:o}}function Yl(e){return t(ue,e)}function Cl(e){n(ue,e)}var le="DeclareVariable";function Ll(e){return{type:le,id:e}}function Bl(e){return t(le,e)}function Ol(e){n(le,e)}var de="EnumDeclaration";function jl(e,r){return{type:de,id:e,body:r}}function Kl(e){return t(de,e)}function Rl(e){n(de,e)}var fe="InterfaceDeclaration";function Ul(e,r,o,i){return{type:fe,id:e,typeParameters:r,extends:o,body:i}}function ql(e){return t(fe,e)}function Wl(e){n(fe,e)}var me="OpaqueType";function _l(e,r,o,i){return{type:me,id:e,typeParameters:r,supertype:o,impltype:i}}function $l(e){return t(me,e)}function Hl(e){n(me,e)}var ce="TypeAlias";function nd(e,r,o){return{type:ce,id:e,typeParameters:r,right:o}}function rd(e){return t(ce,e)}function od(e){n(ce,e)}var ye="ArrayExpression";function Yd(e=[]){return{type:ye,elements:e}}function Cd(e){return t(ye,e)}function wd(e){n(ye,e)}var xe="ArrowFunctionExpression";function Bd(e,r,o=!1){return{type:xe,params:e,body:r,async:o,expression:null}}function Od(e){return t(xe,e)}function Fd(e){n(xe,e)}var Te="AssignmentExpression";function Kd(e,r,o){return{type:Te,operator:e,left:r,right:o}}function Rd(e){return t(Te,e)}function Vd(e){n(Te,e)}var Se="AwaitExpression";function qd(e){return{type:Se,argument:e}}function Wd(e){return t(Se,e)}function Qd(e){n(Se,e)}var Ee="BigIntLiteral";function $d(e){return{type:Ee,value:e}}function Hd(e){return t(Ee,e)}function Zd(e){n(Ee,e)}var be="BinaryExpression";function rf(e,r,o){return{type:be,operator:e,left:r,right:o}}function of(e){return t(be,e)}function sf(e){n(be,e)}var Ne="BindExpression";function lf(e,r){return{type:Ne,object:e,callee:r}}function df(e){return t(Ne,e)}function ff(e){n(Ne,e)}var Pe="BooleanLiteral";function xf(e){return{type:Pe,value:e}}function Tf(e){return t(Pe,e)}function Sf(e){n(Pe,e)}var Ae="CallExpression";function Pf(e,r){return{type:Ae,callee:e,arguments:r}}function Af(e){return t(Ae,e)}function If(e){n(Ae,e)}var Ie="ClassExpression";function Cf(e,r,o,i=null){return{type:Ie,id:e,superClass:r,body:o,decorators:i}}function wf(e){return t(Ie,e)}function hf(e){n(Ie,e)}var De="ConditionalExpression";function Of(e,r,o){return{type:De,test:e,consequent:r,alternate:o}}function Ff(e){return t(De,e)}function Jf(e){n(De,e)}var ge="DecimalLiteral";function Rf(e){return{type:ge,value:e}}function Vf(e){return t(ge,e)}function kf(e){n(ge,e)}var Ye="DoExpression";function Wf(e,r=!1){return{type:Ye,body:e,async:r}}function Qf(e){return t(Ye,e)}function zf(e){n(Ye,e)}var Ce="FunctionExpression";function Hf(e,r,o,i=!1,s=!1){return{type:Ce,id:e,params:r,body:o,generator:i,async:s}}function Zf(e){return t(Ce,e)}function em(e){n(Ce,e)}var we="Identifier";function om(e){return{type:we,name:e}}function im(e){return t(we,e)}function sm(e){n(we,e)}var he="Import";function lm(){return{type:he}}function dm(e){return t(he,e)}function fm(e){n(he,e)}var Me="ImportExpression";function xm(e,r=null){return{type:Me,source:e,options:r}}function Tm(e){return t(Me,e)}function Sm(e){n(Me,e)}var Le="LogicalExpression";function Pm(e,r,o){return{type:Le,operator:e,left:r,right:o}}function Am(e){return t(Le,e)}function Im(e){n(Le,e)}var Be="MemberExpression";function Cm(e,r,o=!1,i=!1){return{type:Be,object:e,property:r,computed:o,optional:i}}function wm(e){return t(Be,e)}function hm(e){n(Be,e)}var Oe="MetaProperty";function Om(e,r){return{type:Oe,meta:e,property:r}}function Fm(e){return t(Oe,e)}function Jm(e){n(Oe,e)}var Fe="ModuleExpression";function Rm(e){return{type:Fe,body:e}}function Vm(e){return t(Fe,e)}function km(e){n(Fe,e)}var Je="NewExpression";function Wm(e,r){return{type:Je,callee:e,arguments:r}}function Qm(e){return t(Je,e)}function zm(e){n(Je,e)}var Xe="NullLiteral";function Hm(){return{type:Xe}}function Zm(e){return t(Xe,e)}function ec(e){n(Xe,e)}var je="NumericLiteral";function oc(e){return{type:je,value:e}}function ic(e){return t(je,e)}function sc(e){n(je,e)}var Ke="ObjectExpression";function lc(e){return{type:Ke,properties:e}}function dc(e){return t(Ke,e)}function fc(e){n(Ke,e)}var Re="OptionalCallExpression";function xc(e,r,o){return{type:Re,callee:e,arguments:r,optional:o}}function Tc(e){return t(Re,e)}function Sc(e){n(Re,e)}var Ve="OptionalMemberExpression";function Pc(e,r,o=!1,i=!1){return{type:Ve,object:e,property:r,computed:o,optional:i}}function Ac(e){return t(Ve,e)}function Ic(e){n(Ve,e)}var ke="ParenthesizedExpression";function Cc(e){return{type:ke,expression:e}}function wc(e){return t(ke,e)}function hc(e){n(ke,e)}var ve="PipelineBareFunction";function Oc(e){return{type:ve,callee:e}}function Fc(e){return t(ve,e)}function Jc(e){n(ve,e)}var Ue="PipelinePrimaryTopicReference";function Rc(){return{type:Ue}}function Vc(e){return t(Ue,e)}function kc(e){n(Ue,e)}var qe="PipelineTopicExpression";function Wc(e){return{type:qe,expression:e}}function Qc(e){return t(qe,e)}function zc(e){n(qe,e)}var We="RecordExpression";function Hc(e){return{type:We,properties:e}}function Zc(e){return t(We,e)}function ey(e){n(We,e)}var Qe="RegExpLiteral";function oy(e,r=""){return{type:Qe,pattern:e,flags:r}}function iy(e){return t(Qe,e)}function sy(e){n(Qe,e)}var ze="SequenceExpression";function ly(e){return{type:ze,expressions:e}}function dy(e){return t(ze,e)}function fy(e){n(ze,e)}var Ge="StringLiteral";function xy(e){return{type:Ge,value:e}}function Ty(e){return t(Ge,e)}function Sy(e){n(Ge,e)}var _e="Super";function Py(){return{type:_e}}function Ay(e){return t(_e,e)}function Iy(e){n(_e,e)}var $e="TaggedTemplateExpression";function Cy(e,r){return{type:$e,tag:e,quasi:r}}function wy(e){return t($e,e)}function hy(e){n($e,e)}var He="TemplateLiteral";function Oy(e,r){return{type:He,quasis:e,expressions:r}}function Fy(e){return t(He,e)}function Jy(e){n(He,e)}var Ze="ThisExpression";function Ry(){return{type:Ze}}function Vy(e){return t(Ze,e)}function ky(e){n(Ze,e)}var et="TopicReference";function Wy(){return{type:et}}function Qy(e){return t(et,e)}function zy(e){n(et,e)}var tt="TupleExpression";function Hy(e=[]){return{type:tt,elements:e}}function Zy(e){return t(tt,e)}function ex(e){n(tt,e)}var nt="UnaryExpression";function ox(e,r,o=!0){return{type:nt,operator:e,argument:r,prefix:o}}function ix(e){return t(nt,e)}function sx(e){n(nt,e)}var rt="UpdateExpression";function lx(e,r,o=!1){return{type:rt,operator:e,argument:r,prefix:o}}function dx(e){return t(rt,e)}function fx(e){n(rt,e)}var ot="YieldExpression";function xx(e=null,r=!1){return{type:ot,argument:e,delegate:r}}function Tx(e){return t(ot,e)}function Sx(e){n(ot,e)}var it="ArgumentPlaceholder";function mT(){return{type:it}}function cT(e){return t(it,e)}function yT(e){n(it,e)}var st="ArrayPattern";function ET(e){return{type:st,elements:e}}function bT(e){return t(st,e)}function NT(e){n(st,e)}var pt="AssignmentPattern";function DT(e,r){return{type:pt,left:e,right:r}}function gT(e){return t(pt,e)}function YT(e){n(pt,e)}var at="CatchClause";function MT(e,r){return{type:at,param:e,body:r}}function LT(e){return t(at,e)}function BT(e){n(at,e)}var ut="ClassAccessorProperty";function XT(e,r=null,o=null,i=null,s=!1,p=!1){return{type:ut,key:e,value:r,typeAnnotation:o,decorators:i,computed:s,static:p}}function jT(e){return t(ut,e)}function KT(e){n(ut,e)}var lt="ClassBody";function vT(e){return{type:lt,body:e}}function UT(e){return t(lt,e)}function qT(e){n(lt,e)}var dt="ClassMethod";function GT(e,r,o,i,s=!1,p=!1,a=!1,u=!1){return{type:dt,kind:e,key:r,params:o,body:i,computed:s,static:p,generator:a,async:u}}function _T(e){return t(dt,e)}function $T(e){n(dt,e)}var ft="ClassPrivateMethod";function tS(e,r,o,i,s=!1,p=!1,a=!1,u=!1){return{type:ft,kind:e,key:r,params:o,body:i,computed:s,static:p,generator:a,async:u}}function nS(e){return t(ft,e)}function rS(e){n(ft,e)}var mt="ClassPrivateProperty";function pS(e,r,o,i=!1){return{type:mt,key:e,value:r,decorators:o,static:i}}function aS(e){return t(mt,e)}function uS(e){n(mt,e)}var ct="ClassProperty";function mS(e,r,o,i,s=!1,p=!1){return{type:ct,key:e,value:r,typeAnnotation:o,decorators:i,computed:s,static:p}}function cS(e){return t(ct,e)}function yS(e){n(ct,e)}var yt="Decorator";function ES(e){return{type:yt,expression:e}}function bS(e){return t(yt,e)}function NS(e){n(yt,e)}var xt="Directive";function DS(e){return{type:xt,value:e}}function gS(e){return t(xt,e)}function YS(e){n(xt,e)}var Tt="DirectiveLiteral";function MS(e){return{type:Tt,value:e}}function LS(e){return t(Tt,e)}function BS(e){n(Tt,e)}var St="ExportDefaultSpecifier";function XS(e){return{type:St,exported:e}}function jS(e){return t(St,e)}function KS(e){n(St,e)}var Et="ExportNamespaceSpecifier";function vS(e){return{type:Et,exported:e}}function US(e){return t(Et,e)}function qS(e){n(Et,e)}var bt="ExportSpecifier";function GS(e,r){return{type:bt,local:e,exported:r}}function _S(e){return t(bt,e)}function $S(e){n(bt,e)}var Nt="ImportDefaultSpecifier";function tE(e){return{type:Nt,local:e}}function nE(e){return t(Nt,e)}function rE(e){n(Nt,e)}var Pt="ImportNamespaceSpecifier";function pE(e){return{type:Pt,local:e}}function aE(e){return t(Pt,e)}function uE(e){n(Pt,e)}var At="ImportSpecifier";function mE(e,r){return{type:At,local:e,imported:r}}function cE(e){return t(At,e)}function yE(e){n(At,e)}var It="ObjectMethod";function EE(e,r,o,i,s=!1,p=!1,a=!1){return{type:It,kind:e,key:r,params:o,body:i,computed:s,generator:p,async:a}}function bE(e){return t(It,e)}function NE(e){n(It,e)}var Dt="ObjectPattern";function DE(e){return{type:Dt,properties:e}}function gE(e){return t(Dt,e)}function YE(e){n(Dt,e)}var gt="ObjectProperty";function ME(e,r,o=!1,i=!1,s=null){return{type:gt,key:e,value:r,computed:o,shorthand:i,decorators:s}}function LE(e){return t(gt,e)}function BE(e){n(gt,e)}var Yt="PrivateName";function XE(e){return{type:Yt,id:e}}function jE(e){return t(Yt,e)}function KE(e){n(Yt,e)}var Ct="RestElement";function vE(e){return{type:Ct,argument:e}}function UE(e){return t(Ct,e)}function qE(e){n(Ct,e)}var wt="SpreadElement";function GE(e){return{type:wt,argument:e}}function _E(e){return t(wt,e)}function $E(e){n(wt,e)}var ht="StaticBlock";function tb(e){return{type:ht,body:e}}function nb(e){return t(ht,e)}function rb(e){n(ht,e)}var Mt="SwitchCase";function pb(e,r){return{type:Mt,test:e,consequent:r}}function ab(e){return t(Mt,e)}function ub(e){n(Mt,e)}var Lt="TemplateElement";function mb(e,r=!1){return{type:Lt,value:e,tail:r}}function cb(e){return t(Lt,e)}function yb(e){n(Lt,e)}var Bt="V8IntrinsicIdentifier";function Eb(e){return{type:Bt,name:e}}function bb(e){return t(Bt,e)}function Nb(e){n(Bt,e)}var Ot="VariableDeclarator";function Db(e,r=null){return{type:Ot,id:e,init:r}}function gb(e){return t(Ot,e)}function Yb(e){n(Ot,e)}var Ft="BlockStatement";function aN(e,r=[]){return{type:Ft,body:e,directives:r}}function uN(e){return t(Ft,e)}function lN(e){n(Ft,e)}var Jt="BreakStatement";function cN(e=null){return{type:Jt,label:e}}function yN(e){return t(Jt,e)}function xN(e){n(Jt,e)}var Xt="ClassDeclaration";function bN(e,r,o,i=null){return{type:Xt,id:e,superClass:r,body:o,decorators:i}}function NN(e){return t(Xt,e)}function PN(e){n(Xt,e)}var jt="ContinueStatement";function gN(e=null){return{type:jt,label:e}}function YN(e){return t(jt,e)}function CN(e){n(jt,e)}var Kt="DebuggerStatement";function LN(){return{type:Kt}}function BN(e){return t(Kt,e)}function ON(e){n(Kt,e)}var Rt="DoWhileStatement";function jN(e,r){return{type:Rt,test:e,body:r}}function KN(e){return t(Rt,e)}function RN(e){n(Rt,e)}var Vt="EmptyStatement";function UN(){return{type:Vt}}function qN(e){return t(Vt,e)}function WN(e){n(Vt,e)}var kt="ExportAllDeclaration";function _N(e){return{type:kt,source:e}}function $N(e){return t(kt,e)}function HN(e){n(kt,e)}var vt="ExportNamedDeclaration";function nP(e=null,r=[],o=null){return{type:vt,declaration:e,specifiers:r,source:o}}function rP(e){return t(vt,e)}function oP(e){n(vt,e)}var Ut="ExpressionStatement";function aP(e){return{type:Ut,expression:e}}function uP(e){return t(Ut,e)}function lP(e){n(Ut,e)}var qt="ForInStatement";function cP(e,r,o){return{type:qt,left:e,right:r,body:o}}function yP(e){return t(qt,e)}function xP(e){n(qt,e)}var Wt="ForOfStatement";function bP(e,r,o,i){return{type:Wt,left:e,right:r,body:o,await:i}}function NP(e){return t(Wt,e)}function PP(e){n(Wt,e)}var Qt="ForStatement";function gP(e,r,o,i){return{type:Qt,init:e,test:r,update:o,body:i}}function YP(e){return t(Qt,e)}function CP(e){n(Qt,e)}var zt="FunctionDeclaration";function LP(e,r,o,i=!1,s=!1){return{type:zt,id:e,params:r,body:o,generator:i,async:s}}function BP(e){return t(zt,e)}function OP(e){n(zt,e)}var Gt="IfStatement";function jP(e,r,o=null){return{type:Gt,test:e,consequent:r,alternate:o}}function KP(e){return t(Gt,e)}function RP(e){n(Gt,e)}var _t="ImportDeclaration";function UP(e,r){return{type:_t,specifiers:e,source:r}}function qP(e){return t(_t,e)}function WP(e){n(_t,e)}var $t="LabeledStatement";function _P(e,r){return{type:$t,label:e,body:r}}function $P(e){return t($t,e)}function HP(e){n($t,e)}var Ht="ReturnStatement";function nA(e=null){return{type:Ht,argument:e}}function rA(e){return t(Ht,e)}function oA(e){n(Ht,e)}var Zt="SwitchStatement";function aA(e,r){return{type:Zt,discriminant:e,cases:r}}function uA(e){return t(Zt,e)}function lA(e){n(Zt,e)}var en="ThrowStatement";function cA(e){return{type:en,argument:e}}function yA(e){return t(en,e)}function xA(e){n(en,e)}var tn="TryStatement";function bA(e,r=null,o=null){return{type:tn,block:e,handler:r,finalizer:o}}function NA(e){return t(tn,e)}function PA(e){n(tn,e)}var nn="VariableDeclaration";function gA(e,r){return{type:nn,kind:e,declarations:r}}function YA(e){return t(nn,e)}function CA(e){n(nn,e)}var rn="WhileStatement";function LA(e,r){return{type:rn,test:e,body:r}}function BA(e){return t(rn,e)}function OA(e){n(rn,e)}var on="WithStatement";function jA(e,r){return{type:on,object:e,body:r}}function KA(e){return t(on,e)}function RA(e){n(on,e)}var sn="JSXAttribute";function EI(e,r=null){return{type:sn,name:e,value:r}}function bI(e){return t(sn,e)}function NI(e){n(sn,e)}var pn="JSXClosingElement";function DI(e){return{type:pn,name:e}}function gI(e){return t(pn,e)}function YI(e){n(pn,e)}var an="JSXClosingFragment";function MI(){return{type:an}}function LI(e){return t(an,e)}function BI(e){n(an,e)}var un="JSXElement";function XI(e,r,o,i=null){return{type:un,openingElement:e,closingElement:r,children:o,selfClosing:i}}function jI(e){return t(un,e)}function KI(e){n(un,e)}var ln="JSXEmptyExpression";function vI(){return{type:ln}}function UI(e){return t(ln,e)}function qI(e){n(ln,e)}var dn="JSXExpressionContainer";function GI(e){return{type:dn,expression:e}}function _I(e){return t(dn,e)}function $I(e){n(dn,e)}var fn="JSXFragment";function tD(e,r,o){return{type:fn,openingFragment:e,closingFragment:r,children:o}}function nD(e){return t(fn,e)}function rD(e){n(fn,e)}var mn="JSXIdentifier";function pD(e){return{type:mn,name:e}}function aD(e){return t(mn,e)}function uD(e){n(mn,e)}var cn="JSXMemberExpression";function mD(e,r){return{type:cn,object:e,property:r}}function cD(e){return t(cn,e)}function yD(e){n(cn,e)}var yn="JSXNamespacedName";function ED(e,r){return{type:yn,namespace:e,name:r}}function bD(e){return t(yn,e)}function ND(e){n(yn,e)}var xn="JSXOpeningElement";function DD(e,r,o=!1){return{type:xn,name:e,attributes:r,selfClosing:o}}function gD(e){return t(xn,e)}function YD(e){n(xn,e)}var Tn="JSXOpeningFragment";function MD(){return{type:Tn}}function LD(e){return t(Tn,e)}function BD(e){n(Tn,e)}var Sn="JSXSpreadAttribute";function XD(e){return{type:Sn,argument:e}}function jD(e){return t(Sn,e)}function KD(e){n(Sn,e)}var En="JSXSpreadChild";function vD(e){return{type:En,expression:e}}function UD(e){return t(En,e)}function qD(e){n(En,e)}var bn="JSXText";function GD(e){return{type:bn,value:e}}function _D(e){return t(bn,e)}function $D(e){n(bn,e)}var Nn="TSAsExpression";function Tg(e,r){return{type:Nn,expression:e,typeAnnotation:r}}function Sg(e){return t(Nn,e)}function Eg(e){n(Nn,e)}var Pn="TSInstantiationExpression";function Ag(e,r=null){return{type:Pn,expression:e,typeParameters:r}}function Ig(e){return t(Pn,e)}function Dg(e){n(Pn,e)}var An="TSNonNullExpression";function wg(e){return{type:An,expression:e}}function hg(e){return t(An,e)}function Mg(e){n(An,e)}var In="TSSatisfiesExpression";function Fg(e,r){return{type:In,expression:e,typeAnnotation:r}}function Jg(e){return t(In,e)}function Xg(e){n(In,e)}var Dn="TSTypeAssertion";function Vg(e,r){return{type:Dn,typeAnnotation:e,expression:r}}function kg(e){return t(Dn,e)}function vg(e){n(Dn,e)}var gn="TSAnyKeyword";function Zg(){return{type:gn}}function eY(e){return t(gn,e)}function tY(e){n(gn,e)}var Yn="TSArrayType";function iY(e){return{type:Yn,elementType:e}}function sY(e){return t(Yn,e)}function pY(e){n(Yn,e)}var Cn="TSBigIntKeyword";function dY(){return{type:Cn}}function fY(e){return t(Cn,e)}function mY(e){n(Cn,e)}var wn="TSBooleanKeyword";function TY(){return{type:wn}}function SY(e){return t(wn,e)}function EY(e){n(wn,e)}var hn="TSCallSignatureDeclaration";function AY(e,r,o=null){return{type:hn,typeParameters:e,parameters:r,typeAnnotation:o}}function IY(e){return t(hn,e)}function DY(e){n(hn,e)}var Mn="TSConditionalType";function wY(e,r,o,i){return{type:Mn,checkType:e,extendsType:r,trueType:o,falseType:i}}function hY(e){return t(Mn,e)}function MY(e){n(Mn,e)}var Ln="TSConstructSignatureDeclaration";function FY(e,r,o=null){return{type:Ln,typeParameters:e,parameters:r,typeAnnotation:o}}function JY(e){return t(Ln,e)}function XY(e){n(Ln,e)}var Bn="TSConstructorType";function VY(e,r,o=null){return{type:Bn,typeParameters:e,parameters:r,typeAnnotation:o}}function kY(e){return t(Bn,e)}function vY(e){n(Bn,e)}var On="TSDeclareMethod";function QY(e,r,o,i,s=null){return{type:On,decorators:e,key:r,typeParameters:o,params:i,returnType:s}}function zY(e){return t(On,e)}function GY(e){n(On,e)}var Fn="TSExpressionWithTypeArguments";function ZY(e,r=null){return{type:Fn,expression:e,typeParameters:r}}function eC(e){return t(Fn,e)}function tC(e){n(Fn,e)}var Jn="TSFunctionType";function iC(e,r,o=null){return{type:Jn,typeParameters:e,parameters:r,typeAnnotation:o}}function sC(e){return t(Jn,e)}function pC(e){n(Jn,e)}var Xn="TSImportType";function dC(e,r=null,o=null){return{type:Xn,argument:e,qualifier:r,typeParameters:o}}function fC(e){return t(Xn,e)}function mC(e){n(Xn,e)}var jn="TSIndexSignature";function TC(e,r=null){return{type:jn,parameters:e,typeAnnotation:r}}function SC(e){return t(jn,e)}function EC(e){n(jn,e)}var Kn="TSIndexedAccessType";function AC(e,r){return{type:Kn,objectType:e,indexType:r}}function IC(e){return t(Kn,e)}function DC(e){n(Kn,e)}var Rn="TSInferType";function wC(e){return{type:Rn,typeParameter:e}}function hC(e){return t(Rn,e)}function MC(e){n(Rn,e)}var Vn="TSIntersectionType";function FC(e){return{type:Vn,types:e}}function JC(e){return t(Vn,e)}function XC(e){n(Vn,e)}var kn="TSIntrinsicKeyword";function VC(){return{type:kn}}function kC(e){return t(kn,e)}function vC(e){n(kn,e)}var vn="TSLiteralType";function QC(e){return{type:vn,literal:e}}function zC(e){return t(vn,e)}function GC(e){n(vn,e)}var Un="TSMappedType";function ZC(e,r=null,o=null){return{type:Un,typeParameter:e,typeAnnotation:r,nameType:o}}function ew(e){return t(Un,e)}function tw(e){n(Un,e)}var qn="TSMethodSignature";function iw(e,r,o,i=null,s="method"){return{type:qn,key:e,typeParameters:r,parameters:o,typeAnnotation:i,kind:s}}function sw(e){return t(qn,e)}function pw(e){n(qn,e)}var Wn="TSModuleBlock";function dw(e){return{type:Wn,body:e}}function fw(e){return t(Wn,e)}function mw(e){n(Wn,e)}var Qn="TSNamedTupleMember";function Tw(e,r,o=!1){return{type:Qn,label:e,elementType:r,optional:o}}function Sw(e){return t(Qn,e)}function Ew(e){n(Qn,e)}var zn="TSNeverKeyword";function Aw(){return{type:zn}}function Iw(e){return t(zn,e)}function Dw(e){n(zn,e)}var Gn="TSNullKeyword";function ww(){return{type:Gn}}function hw(e){return t(Gn,e)}function Mw(e){n(Gn,e)}var _n="TSNumberKeyword";function Fw(){return{type:_n}}function Jw(e){return t(_n,e)}function Xw(e){n(_n,e)}var $n="TSObjectKeyword";function Vw(){return{type:$n}}function kw(e){return t($n,e)}function vw(e){n($n,e)}var Hn="TSOptionalType";function Qw(e){return{type:Hn,typeAnnotation:e}}function zw(e){return t(Hn,e)}function Gw(e){n(Hn,e)}var Zn="TSParameterProperty";function Zw(e){return{type:Zn,parameter:e}}function eh(e){return t(Zn,e)}function th(e){n(Zn,e)}var er="TSParenthesizedType";function ih(e){return{type:er,typeAnnotation:e}}function sh(e){return t(er,e)}function ph(e){n(er,e)}var tr="TSPropertySignature";function dh(e,r=null,o=null){return{type:tr,key:e,typeAnnotation:r,kind:o}}function fh(e){return t(tr,e)}function mh(e){n(tr,e)}var nr="TSQualifiedName";function Th(e,r){return{type:nr,left:e,right:r}}function Sh(e){return t(nr,e)}function Eh(e){n(nr,e)}var rr="TSRestType";function Ah(e){return{type:rr,typeAnnotation:e}}function Ih(e){return t(rr,e)}function Dh(e){n(rr,e)}var or="TSStringKeyword";function wh(){return{type:or}}function hh(e){return t(or,e)}function Mh(e){n(or,e)}var ir="TSSymbolKeyword";function Fh(){return{type:ir}}function Jh(e){return t(ir,e)}function Xh(e){n(ir,e)}var sr="TSThisType";function Vh(){return{type:sr}}function kh(e){return t(sr,e)}function vh(e){n(sr,e)}var pr="TSTupleType";function Qh(e){return{type:pr,elementTypes:e}}function zh(e){return t(pr,e)}function Gh(e){n(pr,e)}var ar="TSTypeAnnotation";function Zh(e){return{type:ar,typeAnnotation:e}}function eM(e){return t(ar,e)}function tM(e){n(ar,e)}var ur="TSTypeLiteral";function iM(e){return{type:ur,members:e}}function sM(e){return t(ur,e)}function pM(e){n(ur,e)}var lr="TSTypeOperator";function dM(e,r="keyof"){return{type:lr,typeAnnotation:e,operator:r}}function fM(e){return t(lr,e)}function mM(e){n(lr,e)}var dr="TSTypeParameter";function TM(e,r,o){return{type:dr,constraint:e,default:r,name:o}}function SM(e){return t(dr,e)}function EM(e){n(dr,e)}var fr="TSTypeParameterDeclaration";function AM(e){return{type:fr,params:e}}function IM(e){return t(fr,e)}function DM(e){n(fr,e)}var mr="TSTypeParameterInstantiation";function wM(e){return{type:mr,params:e}}function hM(e){return t(mr,e)}function MM(e){n(mr,e)}var cr="TSTypePredicate";function FM(e,r=null,o=null){return{type:cr,parameterName:e,typeAnnotation:r,asserts:o}}function JM(e){return t(cr,e)}function XM(e){n(cr,e)}var yr="TSTypeQuery";function VM(e,r=null){return{type:yr,exprName:e,typeParameters:r}}function kM(e){return t(yr,e)}function vM(e){n(yr,e)}var xr="TSTypeReference";function QM(e,r=null){return{type:xr,typeName:e,typeParameters:r}}function zM(e){return t(xr,e)}function GM(e){n(xr,e)}var Tr="TSUndefinedKeyword";function ZM(){return{type:Tr}}function eL(e){return t(Tr,e)}function tL(e){n(Tr,e)}var Sr="TSUnionType";function iL(e){return{type:Sr,types:e}}function sL(e){return t(Sr,e)}function pL(e){n(Sr,e)}var Er="TSUnknownKeyword";function dL(){return{type:Er}}function fL(e){return t(Er,e)}function mL(e){n(Er,e)}var br="TSVoidKeyword";function TL(){return{type:br}}function SL(e){return t(br,e)}function EL(e){n(br,e)}var Nr="TSDeclareFunction";function EB(e,r,o,i){return{type:Nr,id:e,typeParameters:r,params:o,returnType:i}}function bB(e){return t(Nr,e)}function NB(e){n(Nr,e)}var Pr="TSEnumDeclaration";function DB(e,r){return{type:Pr,id:e,members:r}}function gB(e){return t(Pr,e)}function YB(e){n(Pr,e)}var Ar="TSExportAssignment";function MB(e){return{type:Ar,expression:e}}function LB(e){return t(Ar,e)}function BB(e){n(Ar,e)}var Ir="TSImportEqualsDeclaration";function XB(e,r){return{type:Ir,id:e,moduleReference:r,isExport:!1}}function jB(e){return t(Ir,e)}function KB(e){n(Ir,e)}var Dr="TSInterfaceDeclaration";function vB(e,r,o,i){return{type:Dr,id:e,typeParameters:r,extends:o,body:i}}function UB(e){return t(Dr,e)}function qB(e){n(Dr,e)}var gr="TSModuleDeclaration";function GB(e,r){return{type:gr,id:e,body:r}}function _B(e){return t(gr,e)}function $B(e){n(gr,e)}var Yr="TSNamespaceExportDeclaration";function tO(e){return{type:Yr,id:e}}function nO(e){return t(Yr,e)}function rO(e){n(Yr,e)}var Cr="TSTypeAliasDeclaration";function pO(e,r,o){return{type:Cr,id:e,typeParameters:r,typeAnnotation:o}}function aO(e){return t(Cr,e)}function uO(e){n(Cr,e)}export{lm as _import,Py as _super,hr as addComment,wr as addComments,Wr as anyTypeAnnotation,mT as argumentPlaceholder,Yd as arrayExpression,ET as arrayPattern,Hr as arrayTypeAnnotation,Bd as arrowFunctionExpression,zr as assertAnyTypeAnnotation,yT as assertArgumentPlaceholder,wd as assertArrayExpression,NT as assertArrayPattern,eo as assertArrayTypeAnnotation,Fd as assertArrowFunctionExpression,Vd as assertAssignmentExpression,YT as assertAssignmentPattern,Qd as assertAwaitExpression,Zd as assertBigIntLiteral,sf as assertBinaryExpression,ff as assertBindExpression,lN as assertBlockStatement,Sf as assertBooleanLiteral,so as assertBooleanLiteralTypeAnnotation,mo as assertBooleanTypeAnnotation,xN as assertBreakStatement,If as assertCallExpression,BT as assertCatchClause,KT as assertClassAccessorProperty,qT as assertClassBody,PN as assertClassDeclaration,hf as assertClassExpression,$T as assertClassMethod,rS as assertClassPrivateMethod,uS as assertClassPrivateProperty,yS as assertClassProperty,Jf as assertConditionalExpression,CN as assertContinueStatement,ON as assertDebuggerStatement,kf as assertDecimalLiteral,Ou as assertDeclareClass,Ru as assertDeclareExportAllDeclaration,Wu as assertDeclareExportDeclaration,Hu as assertDeclareFunction,ol as assertDeclareInterface,ll as assertDeclareModule,xl as assertDeclareModuleExports,Pl as assertDeclareOpaqueType,Cl as assertDeclareTypeAlias,Ol as assertDeclareVariable,NS as assertDecorator,YS as assertDirective,BS as assertDirectiveLiteral,zf as assertDoExpression,RN as assertDoWhileStatement,WN as assertEmptyStatement,Eo as assertEmptyTypeAnnotation,Do as assertEnumBooleanBody,Mo as assertEnumBooleanMember,Rl as assertEnumDeclaration,Xo as assertEnumDefaultedMember,vo as assertEnumNumberBody,Go as assertEnumNumberMember,ti as assertEnumStringBody,pi as assertEnumStringMember,mi as assertEnumSymbolBody,Ei as assertExistsTypeAnnotation,HN as assertExportAllDeclaration,KS as assertExportDefaultSpecifier,oP as assertExportNamedDeclaration,qS as assertExportNamespaceSpecifier,$S as assertExportSpecifier,lP as assertExpressionStatement,xP as assertForInStatement,PP as assertForOfStatement,CP as assertForStatement,OP as assertFunctionDeclaration,em as assertFunctionExpression,Di as assertFunctionTypeAnnotation,Mi as assertFunctionTypeParam,Xi as assertGenericTypeAnnotation,sm as assertIdentifier,RP as assertIfStatement,fm as assertImport,WP as assertImportDeclaration,rE as assertImportDefaultSpecifier,Sm as assertImportExpression,uE as assertImportNamespaceSpecifier,yE as assertImportSpecifier,vi as assertIndexedAccessType,Wl as assertInterfaceDeclaration,Gi as assertInterfaceExtends,ts as assertInterfaceTypeAnnotation,ps as assertIntersectionTypeAnnotation,NI as assertJSXAttribute,YI as assertJSXClosingElement,BI as assertJSXClosingFragment,KI as assertJSXElement,qI as assertJSXEmptyExpression,$I as assertJSXExpressionContainer,rD as assertJSXFragment,uD as assertJSXIdentifier,yD as assertJSXMemberExpression,ND as assertJSXNamespacedName,YD as assertJSXOpeningElement,BD as assertJSXOpeningFragment,KD as assertJSXSpreadAttribute,qD as assertJSXSpreadChild,$D as assertJSXText,HP as assertLabeledStatement,Im as assertLogicalExpression,hm as assertMemberExpression,Jm as assertMetaProperty,ms as assertMixedTypeAnnotation,km as assertModuleExpression,zm as assertNewExpression,ec as assertNullLiteral,Es as assertNullLiteralTypeAnnotation,Ds as assertNullableTypeAnnotation,Ms as assertNumberLiteralTypeAnnotation,Xs as assertNumberTypeAnnotation,sc as assertNumericLiteral,fc as assertObjectExpression,NE as assertObjectMethod,YE as assertObjectPattern,BE as assertObjectProperty,vs as assertObjectTypeAnnotation,Gs as assertObjectTypeCallProperty,tp as assertObjectTypeIndexer,pp as assertObjectTypeInternalSlot,mp as assertObjectTypeProperty,Ep as assertObjectTypeSpreadProperty,Hl as assertOpaqueType,Sc as assertOptionalCallExpression,Dp as assertOptionalIndexedAccessType,Ic as assertOptionalMemberExpression,hc as assertParenthesizedExpression,Jc as assertPipelineBareFunction,kc as assertPipelinePrimaryTopicReference,zc as assertPipelineTopicExpression,KE as assertPrivateName,Mp as assertQualifiedTypeIdentifier,ey as assertRecordExpression,sy as assertRegExpLiteral,qE as assertRestElement,oA as assertReturnStatement,fy as assertSequenceExpression,$E as assertSpreadElement,rb as assertStaticBlock,Sy as assertStringLiteral,Xp as assertStringLiteralTypeAnnotation,vp as assertStringTypeAnnotation,Iy as assertSuper,ub as assertSwitchCase,lA as assertSwitchStatement,Gp as assertSymbolTypeAnnotation,tY as assertTSAnyKeyword,pY as assertTSArrayType,Eg as assertTSAsExpression,mY as assertTSBigIntKeyword,EY as assertTSBooleanKeyword,DY as assertTSCallSignatureDeclaration,MY as assertTSConditionalType,XY as assertTSConstructSignatureDeclaration,vY as assertTSConstructorType,NB as assertTSDeclareFunction,GY as assertTSDeclareMethod,YB as assertTSEnumDeclaration,BB as assertTSExportAssignment,tC as assertTSExpressionWithTypeArguments,pC as assertTSFunctionType,KB as assertTSImportEqualsDeclaration,mC as assertTSImportType,EC as assertTSIndexSignature,DC as assertTSIndexedAccessType,MC as assertTSInferType,Dg as assertTSInstantiationExpression,qB as assertTSInterfaceDeclaration,XC as assertTSIntersectionType,vC as assertTSIntrinsicKeyword,GC as assertTSLiteralType,tw as assertTSMappedType,pw as assertTSMethodSignature,mw as assertTSModuleBlock,$B as assertTSModuleDeclaration,Ew as assertTSNamedTupleMember,rO as assertTSNamespaceExportDeclaration,Dw as assertTSNeverKeyword,Mg as assertTSNonNullExpression,Mw as assertTSNullKeyword,Xw as assertTSNumberKeyword,vw as assertTSObjectKeyword,Gw as assertTSOptionalType,th as assertTSParameterProperty,ph as assertTSParenthesizedType,mh as assertTSPropertySignature,Eh as assertTSQualifiedName,Dh as assertTSRestType,Xg as assertTSSatisfiesExpression,Mh as assertTSStringKeyword,Xh as assertTSSymbolKeyword,vh as assertTSThisType,Gh as assertTSTupleType,uO as assertTSTypeAliasDeclaration,tM as assertTSTypeAnnotation,vg as assertTSTypeAssertion,pM as assertTSTypeLiteral,mM as assertTSTypeOperator,EM as assertTSTypeParameter,DM as assertTSTypeParameterDeclaration,MM as assertTSTypeParameterInstantiation,XM as assertTSTypePredicate,vM as assertTSTypeQuery,GM as assertTSTypeReference,tL as assertTSUndefinedKeyword,pL as assertTSUnionType,mL as assertTSUnknownKeyword,EL as assertTSVoidKeyword,hy as assertTaggedTemplateExpression,yb as assertTemplateElement,Jy as assertTemplateLiteral,ky as assertThisExpression,ta as assertThisTypeAnnotation,xA as assertThrowStatement,zy as assertTopicReference,PA as assertTryStatement,ex as assertTupleExpression,pa as assertTupleTypeAnnotation,od as assertTypeAlias,ma as assertTypeAnnotation,Rr as assertTypeCastExpression,Ea as assertTypeofTypeAnnotation,sx as assertUnaryExpression,Da as assertUnionTypeAnnotation,fx as assertUpdateExpression,Nb as assertV8IntrinsicIdentifier,CA as assertVariableDeclaration,Yb as assertVariableDeclarator,Ma as assertVariance,Xa as assertVoidTypeAnnotation,OA as assertWhileStatement,RA as assertWithStatement,Sx as assertYieldExpression,Kd as assignmentExpression,DT as assignmentPattern,qd as awaitExpression,$d as bigIntLiteral,rf as binaryExpression,lf as bindExpression,aN as blockStatement,xf as booleanLiteral,oo as booleanLiteralTypeAnnotation,lo as booleanTypeAnnotation,cN as breakStatement,Pf as callExpression,MT as catchClause,XT as classAccessorProperty,vT as classBody,bN as classDeclaration,Cf as classExpression,GT as classMethod,tS as classPrivateMethod,pS as classPrivateProperty,mS as classProperty,Of as conditionalExpression,gN as continueStatement,LN as debuggerStatement,Rf as decimalLiteral,Lu as declareClass,ju as declareExportAllDeclaration,Uu as declareExportDeclaration,_u as declareFunction,nl as declareInterface,al as declareModule,cl as declareModuleExports,bl as declareOpaqueType,gl as declareTypeAlias,Ll as declareVariable,ES as decorator,DS as directive,MS as directiveLiteral,Wf as doExpression,jN as doWhileStatement,UN as emptyStatement,To as emptyTypeAnnotation,Ao as enumBooleanBody,wo as enumBooleanMember,jl as enumDeclaration,Fo as enumDefaultedMember,Vo as enumNumberBody,Qo as enumNumberMember,Zo as enumStringBody,ii as enumStringMember,di as enumSymbolBody,Ti as existsTypeAnnotation,_N as exportAllDeclaration,XS as exportDefaultSpecifier,nP as exportNamedDeclaration,vS as exportNamespaceSpecifier,GS as exportSpecifier,aP as expressionStatement,cP as forInStatement,bP as forOfStatement,gP as forStatement,LP as functionDeclaration,Hf as functionExpression,Ai as functionTypeAnnotation,wi as functionTypeParam,Fi as genericTypeAnnotation,om as identifier,jP as ifStatement,UP as importDeclaration,tE as importDefaultSpecifier,xm as importExpression,pE as importNamespaceSpecifier,mE as importSpecifier,Vi as indexedAccessType,Ul as interfaceDeclaration,Qi as interfaceExtends,Zi as interfaceTypeAnnotation,is as intersectionTypeAnnotation,Qr as isAnyTypeAnnotation,cT as isArgumentPlaceholder,Cd as isArrayExpression,bT as isArrayPattern,Zr as isArrayTypeAnnotation,Od as isArrowFunctionExpression,Rd as isAssignmentExpression,gT as isAssignmentPattern,Wd as isAwaitExpression,Hd as isBigIntLiteral,of as isBinaryExpression,df as isBindExpression,uN as isBlockStatement,Tf as isBooleanLiteral,io as isBooleanLiteralTypeAnnotation,fo as isBooleanTypeAnnotation,yN as isBreakStatement,Af as isCallExpression,LT as isCatchClause,jT as isClassAccessorProperty,UT as isClassBody,NN as isClassDeclaration,wf as isClassExpression,_T as isClassMethod,nS as isClassPrivateMethod,aS as isClassPrivateProperty,cS as isClassProperty,Ff as isConditionalExpression,YN as isContinueStatement,BN as isDebuggerStatement,Vf as isDecimalLiteral,Bu as isDeclareClass,Ku as isDeclareExportAllDeclaration,qu as isDeclareExportDeclaration,$u as isDeclareFunction,rl as isDeclareInterface,ul as isDeclareModule,yl as isDeclareModuleExports,Nl as isDeclareOpaqueType,Yl as isDeclareTypeAlias,Bl as isDeclareVariable,bS as isDecorator,gS as isDirective,LS as isDirectiveLiteral,Qf as isDoExpression,KN as isDoWhileStatement,qN as isEmptyStatement,So as isEmptyTypeAnnotation,Io as isEnumBooleanBody,ho as isEnumBooleanMember,Kl as isEnumDeclaration,Jo as isEnumDefaultedMember,ko as isEnumNumberBody,zo as isEnumNumberMember,ei as isEnumStringBody,si as isEnumStringMember,fi as isEnumSymbolBody,Si as isExistsTypeAnnotation,$N as isExportAllDeclaration,jS as isExportDefaultSpecifier,rP as isExportNamedDeclaration,US as isExportNamespaceSpecifier,_S as isExportSpecifier,uP as isExpressionStatement,yP as isForInStatement,NP as isForOfStatement,YP as isForStatement,BP as isFunctionDeclaration,Zf as isFunctionExpression,Ii as isFunctionTypeAnnotation,hi as isFunctionTypeParam,Ji as isGenericTypeAnnotation,im as isIdentifier,KP as isIfStatement,dm as isImport,qP as isImportDeclaration,nE as isImportDefaultSpecifier,Tm as isImportExpression,aE as isImportNamespaceSpecifier,cE as isImportSpecifier,ki as isIndexedAccessType,ql as isInterfaceDeclaration,zi as isInterfaceExtends,es as isInterfaceTypeAnnotation,ss as isIntersectionTypeAnnotation,bI as isJSXAttribute,gI as isJSXClosingElement,LI as isJSXClosingFragment,jI as isJSXElement,UI as isJSXEmptyExpression,_I as isJSXExpressionContainer,nD as isJSXFragment,aD as isJSXIdentifier,cD as isJSXMemberExpression,bD as isJSXNamespacedName,gD as isJSXOpeningElement,LD as isJSXOpeningFragment,jD as isJSXSpreadAttribute,UD as isJSXSpreadChild,_D as isJSXText,$P as isLabeledStatement,Am as isLogicalExpression,wm as isMemberExpression,Fm as isMetaProperty,fs as isMixedTypeAnnotation,Vm as isModuleExpression,Qm as isNewExpression,Zm as isNullLiteral,Ss as isNullLiteralTypeAnnotation,Is as isNullableTypeAnnotation,hs as isNumberLiteralTypeAnnotation,Js as isNumberTypeAnnotation,ic as isNumericLiteral,dc as isObjectExpression,bE as isObjectMethod,gE as isObjectPattern,LE as isObjectProperty,ks as isObjectTypeAnnotation,zs as isObjectTypeCallProperty,ep as isObjectTypeIndexer,sp as isObjectTypeInternalSlot,fp as isObjectTypeProperty,Sp as isObjectTypeSpreadProperty,$l as isOpaqueType,Tc as isOptionalCallExpression,Ip as isOptionalIndexedAccessType,Ac as isOptionalMemberExpression,wc as isParenthesizedExpression,Fc as isPipelineBareFunction,Vc as isPipelinePrimaryTopicReference,Qc as isPipelineTopicExpression,jE as isPrivateName,hp as isQualifiedTypeIdentifier,Zc as isRecordExpression,iy as isRegExpLiteral,UE as isRestElement,rA as isReturnStatement,dy as isSequenceExpression,_E as isSpreadElement,nb as isStaticBlock,Ty as isStringLiteral,Jp as isStringLiteralTypeAnnotation,kp as isStringTypeAnnotation,Ay as isSuper,ab as isSwitchCase,uA as isSwitchStatement,zp as isSymbolTypeAnnotation,eY as isTSAnyKeyword,sY as isTSArrayType,Sg as isTSAsExpression,fY as isTSBigIntKeyword,SY as isTSBooleanKeyword,IY as isTSCallSignatureDeclaration,hY as isTSConditionalType,JY as isTSConstructSignatureDeclaration,kY as isTSConstructorType,bB as isTSDeclareFunction,zY as isTSDeclareMethod,gB as isTSEnumDeclaration,LB as isTSExportAssignment,eC as isTSExpressionWithTypeArguments,sC as isTSFunctionType,jB as isTSImportEqualsDeclaration,fC as isTSImportType,SC as isTSIndexSignature,IC as isTSIndexedAccessType,hC as isTSInferType,Ig as isTSInstantiationExpression,UB as isTSInterfaceDeclaration,JC as isTSIntersectionType,kC as isTSIntrinsicKeyword,zC as isTSLiteralType,ew as isTSMappedType,sw as isTSMethodSignature,fw as isTSModuleBlock,_B as isTSModuleDeclaration,Sw as isTSNamedTupleMember,nO as isTSNamespaceExportDeclaration,Iw as isTSNeverKeyword,hg as isTSNonNullExpression,hw as isTSNullKeyword,Jw as isTSNumberKeyword,kw as isTSObjectKeyword,zw as isTSOptionalType,eh as isTSParameterProperty,sh as isTSParenthesizedType,fh as isTSPropertySignature,Sh as isTSQualifiedName,Ih as isTSRestType,Jg as isTSSatisfiesExpression,hh as isTSStringKeyword,Jh as isTSSymbolKeyword,kh as isTSThisType,zh as isTSTupleType,aO as isTSTypeAliasDeclaration,eM as isTSTypeAnnotation,kg as isTSTypeAssertion,sM as isTSTypeLiteral,fM as isTSTypeOperator,SM as isTSTypeParameter,IM as isTSTypeParameterDeclaration,hM as isTSTypeParameterInstantiation,JM as isTSTypePredicate,kM as isTSTypeQuery,zM as isTSTypeReference,eL as isTSUndefinedKeyword,sL as isTSUnionType,fL as isTSUnknownKeyword,SL as isTSVoidKeyword,wy as isTaggedTemplateExpression,cb as isTemplateElement,Fy as isTemplateLiteral,Vy as isThisExpression,ea as isThisTypeAnnotation,yA as isThrowStatement,Qy as isTopicReference,NA as isTryStatement,Zy as isTupleExpression,sa as isTupleTypeAnnotation,rd as isTypeAlias,fa as isTypeAnnotation,Kr as isTypeCastExpression,Sa as isTypeofTypeAnnotation,ix as isUnaryExpression,Ia as isUnionTypeAnnotation,dx as isUpdateExpression,bb as isV8IntrinsicIdentifier,YA as isVariableDeclaration,gb as isVariableDeclarator,ha as isVariance,Ja as isVoidTypeAnnotation,BA as isWhileStatement,KA as isWithStatement,Tx as isYieldExpression,EI as jsxAttribute,DI as jsxClosingElement,MI as jsxClosingFragment,XI as jsxElement,vI as jsxEmptyExpression,GI as jsxExpressionContainer,tD as jsxFragment,pD as jsxIdentifier,mD as jsxMemberExpression,ED as jsxNamespacedName,DD as jsxOpeningElement,MD as jsxOpeningFragment,XD as jsxSpreadAttribute,vD as jsxSpreadChild,GD as jsxText,_P as labeledStatement,Pm as logicalExpression,Cm as memberExpression,Om as metaProperty,ds as mixedTypeAnnotation,Rm as moduleExpression,Wm as newExpression,Hm as nullLiteral,Ts as nullLiteralTypeAnnotation,As as nullableTypeAnnotation,ws as numberLiteralTypeAnnotation,Fs as numberTypeAnnotation,oc as numericLiteral,lc as objectExpression,EE as objectMethod,DE as objectPattern,ME as objectProperty,Vs as objectTypeAnnotation,Qs as objectTypeCallProperty,Zs as objectTypeIndexer,ip as objectTypeInternalSlot,dp as objectTypeProperty,Tp as objectTypeSpreadProperty,_l as opaqueType,xc as optionalCallExpression,Ap as optionalIndexedAccessType,Pc as optionalMemberExpression,Cc as parenthesizedExpression,Oc as pipelineBareFunction,Rc as pipelinePrimaryTopicReference,Wc as pipelineTopicExpression,XE as privateName,wp as qualifiedTypeIdentifier,Hc as recordExpression,oy as regExpLiteral,vE as restElement,nA as returnStatement,ly as sequenceExpression,GE as spreadElement,tb as staticBlock,xy as stringLiteral,Fp as stringLiteralTypeAnnotation,Vp as stringTypeAnnotation,pb as switchCase,aA as switchStatement,Qp as symbolTypeAnnotation,Cy as taggedTemplateExpression,mb as templateElement,Oy as templateLiteral,Ry as thisExpression,Zp as thisTypeAnnotation,cA as throwStatement,Wy as topicReference,bA as tryStatement,Zg as tsAnyKeyword,iY as tsArrayType,Tg as tsAsExpression,dY as tsBigIntKeyword,TY as tsBooleanKeyword,AY as tsCallSignatureDeclaration,wY as tsConditionalType,FY as tsConstructSignatureDeclaration,VY as tsConstructorType,EB as tsDeclareFunction,QY as tsDeclareMethod,DB as tsEnumDeclaration,MB as tsExportAssignment,ZY as tsExpressionWithTypeArguments,iC as tsFunctionType,XB as tsImportEqualsDeclaration,dC as tsImportType,TC as tsIndexSignature,AC as tsIndexedAccessType,wC as tsInferType,Ag as tsInstantiationExpression,vB as tsInterfaceDeclaration,FC as tsIntersectionType,VC as tsIntrinsicKeyword,QC as tsLiteralType,ZC as tsMappedType,iw as tsMethodSignature,dw as tsModuleBlock,GB as tsModuleDeclaration,Tw as tsNamedTupleMember,tO as tsNamespaceExportDeclaration,Aw as tsNeverKeyword,wg as tsNonNullExpression,ww as tsNullKeyword,Fw as tsNumberKeyword,Vw as tsObjectKeyword,Qw as tsOptionalType,Zw as tsParameterProperty,ih as tsParenthesizedType,dh as tsPropertySignature,Th as tsQualifiedName,Ah as tsRestType,Fg as tsSatisfiesExpression,wh as tsStringKeyword,Fh as tsSymbolKeyword,Vh as tsThisType,Qh as tsTupleType,pO as tsTypeAliasDeclaration,Zh as tsTypeAnnotation,Vg as tsTypeAssertion,iM as tsTypeLiteral,dM as tsTypeOperator,TM as tsTypeParameter,AM as tsTypeParameterDeclaration,wM as tsTypeParameterInstantiation,FM as tsTypePredicate,VM as tsTypeQuery,QM as tsTypeReference,ZM as tsUndefinedKeyword,iL as tsUnionType,dL as tsUnknownKeyword,TL as tsVoidKeyword,Hy as tupleExpression,ia as tupleTypeAnnotation,nd as typeAlias,da as typeAnnotation,jr as typeCastExpression,Ta as typeofTypeAnnotation,ox as unaryExpression,Aa as unionTypeAnnotation,lx as updateExpression,Eb as v8IntrinsicIdentifier,gA as variableDeclaration,Db as variableDeclarator,wa as variance,Fa as voidTypeAnnotation,LA as whileStatement,jA as withStatement,xx as yieldExpression};
